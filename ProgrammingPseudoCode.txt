
================================================
    ARRAYS
================================================

 Array tricks to explore
---------------------------------------
- Having a separate index from loop index.
- See if you can traverse from end to front instead of regular front to end.
- See if you can have start and end pointers and move towards the middle.
- Using dutch national flag.
- See if you can start from middle and expand outwards.

- For Stock Buy and Sell :
	- remember to store minSoFar if only 1 transaction is allowed.
	- For multiple transactions,keep taking successive diffs and adding it to sum if diffs > 0
	- if only 2 transactions are allowed, it's lot more complicated.

- Rotaing an array k times (LC:189): 
	Use three reverse calls just as in sentence reversal. use k=k%sz for k> sz 

 2-D Array
------------------------

- RotateImage 
	Reverse() followed by swapping i,j


- Set Matrix  Zeroes (lc 73):
	- to delay the row manipulation until you get to row below by using two flags:clearCurrentRow and clearPreviousRow.
	- If you encounter zero for a column, zero out only columns above. 
	- If column above has value zero, set current element to zero
	- Handle last row using clearPreviowRowFlag


- Diagnose Traverse of 2D matrix (lc 498):
	- Only two movements to consider: Diagonally downward to the left, OR Diagonally upward to the right.
	- Diagonal motion is where row is increased by 1 and col is decremented by 1 or vice-versa
	- When you hit top row, you either move to right or if you have reached last col, move down
	- when you hit leftmost col, you either move down or if you have reached last row, move right.
	- Exit the loop when you getto the last element.
	
	
- Spiral Traverse (lc 54):
	- Only three things are needed: matrix size (mxn), startRow, startCol
	- For every new iteration: 
		m -= 2
		n -= 2
		startRow +=1
		startCol +=1
	- One outer while-loop while(m>=1 && n >=1) and 4  inner for-loops for every (m,n) pair. 
	- Terminating condition of all 4 for-loops:
		j<startCol+n; 
		i<startRow+m; 
		i!=startRow && j>=startCol
		i>startRow && (startCol+n-2 >= startCol)
		
	- IMPORTANT:  In the 3rd and 4th for-loops, do extra checks in for-loop initialization itself to make sure we are not 		traversing the same row, col. This is to handle 1 row,1 col case.
	
	
- Search in Sorted 2D Matrix (lc 248)
	- Start with top rightmost element . Lets call it e.
	- If target==e, return true;
	- If target<e; --col;
	- If target>e; ++row;
	Do this while(row<m && col >=0)
	
	
- Sparse multiplication (lc: 311):
	- You need 3 for-loops for matrix multiplication.
     - Best explanation for sparse matrix: 
	https://leetcode.com/problems/sparse-matrix-multiplication/discuss/419538/What-the-interviewer-is-expecting-when-this-problem-is-asked-in-an-interview...
	
	

========================================================================================
Longest Substring Problems (sliding window)
========================================================================================
 - General idea is to use hashMap<char,int> and compute sliding window of size as (i-startIndex+1). 
 - Key is to figure out what to store in hashMap  and when to shrink/expand the window 
 - Most of these problems are O(n).
 - Be VERY, VERY CAREFUL about when to use inner while loop vs if loop
 
1.  Longest Substring Without Repeating Characters (lc: 3 and educative)
-----------
	The key aspects are:
		- hMap[s[i]]=i; //storing the index where the char was last found
		- When you hit a duplicate char, update startIndex = max(startIndex,hMap[s[i]]+1)
		- maxLength=max(maxLength, i-startIndex+1);


2. Longest Substring with Same Letters after at most k Replacement (lc 424 and educative): Very tricky
-------------

We’ll iterate through the string to add one letter at a time in the window. We’ll also keep track of the count of the maximum repeating letter in any window (let’s call it maxRepeatLetterCount). So at any time, we know that we can have a window which has one letter repeating maxRepeatLetterCount times, this means we should try to replace the remaining letters. If we have more than ‘k’ remaining letters, we should shrink the window as we are not allowed to replace more than ‘k’ letters."
     The keys are:
     	- hMap[str[i]]++;
        -  maxLetterLength=max(maxLetterLength, hMap[str[i]]);
        - if(i-startIndex+1 - maxLetterLength > k){
                hMap[str[startIndex]]--;
                ++startIndex;
            }
	 - maxLength=max(maxLength, i-startIndex+1);


3. Longest Substring with At Most K Distinct Character (lc 340)
---------------
    - Here, if the hashMap size > K for a given window, shrink the window until map size <= k. So, the key points are:
      while(hMap.size() > k){
	hMap[s[startIndex]]--;
	if(hMap[s[startIndex]]==0)
	    hMap.erase(s[startIndex]);
	++startIndex;

      }
      maxLength=max(maxLength, i-startIndex+1);


4. Longest String Chain (lc: 1048)
--------
https://leetcode.com/problems/longest-string-chain/discuss/458632/Simple-easy-to-follow-36-ms-solution-using-a-single-hash-map



============================================
SUB-ARRAY SUMS
============================================
 - General idea for sub-array sums with successive elements is to have runniung sum and use hashMap<int,int> that stores sum in some fashion.  
 - Most of these problems are O(n).
- Remember: At given index: sum - (sum-k) will result in target k


1: Maximum Subarray (lc: 53)
---------
To determine max sum in array with  +ve & -ve, you have to determine local max at every index and use that to compute global max at every index. Return global max.


2: Subarray Sum Equals K: To determine *NUMBER* of subarrays that sum to K (lc: 560)
-----------
	- KEY Understand that at given index: sum - (sum-k) will result in target k. So the goal is to know whether sum-k was 	     seen earlier and if so, how many times:
		 if(hMap.count(sum-k)) 
		 	ans+= hMap[sum-k];
		hMap[sum]++
	- Don't forget hMap[0]++
	
	
3: To check if the NON-negative array has a continuous subarray of size at least 2 that sums up to a multiple of k (lc: 523)
--------------
 	Key: Remember remainder theorem: (A+(n * k)) % k = A%k.
  	a) hMap[0]=-1;  //to handle the case [0,0]
        b) runningSum %= k;  //when k!=0
        c) if(hMap.count(runningSum)){
                if(i-hMap[runningSum] > 1)
                    return true;
            }
            else //to handle [0,0]
                hMap[runningSum]=i;
 
 
 4. Smallest Subarray Of Positive Integers with sum >= K (lc:209, educative):
 ---------------
 	Here you dont need hash. Keep adding till sum >= K. then shrink sliding window until sum becomes < k. Move forward.
	
	
	
 5. 3 sum or  4 sum problem where any a+b+c=target in a given array, it follows a different pattern as follows (lc: 15,16,18)
 	- sort the vector first
	- Outer for-loop runs the lenght of vector.
	- Last two nums will be taken from start and end of the vector converging inwards in a while loop
		 for(i=0;...){
		 	newTarget=target-nums[i] ; j=i+1; k=nums.size()
		 	while(j<k) {
				if(nums[j]+nums[k] < newTarget)
					j++;
				if(nums[j]+nums[k] > newTarget)
					--k;
				else (nums[j]+nums[k]==target)
			   		store the values, eliminate duplicates for nums[j] and nums[j] using two while loops
		  	}
			another while loop for eliminating duplicates of nums[i]
		   }
		 
 	
	
================================================
    STRINGS
================================================

KEY TAKEAWAYS:
- To know if a substring characters is part of another bigger substring, put target word as map and word-to-check in hashMap and just compare the counts
- To know if the word is anagram of another,  put the chars in hashmap and also keep track of the sum of all chars.
- To know if string B is rotated version of A, look for A+A.find(B) provided lengths are same

1. Palindrome string
-----------
	-Two indices: at start and end. 
	- Use isaplhanum() and tolower()


2.  Reverse sentence
------------
	3 calls to reverse()
	     -Reverse the whole sentence using reverse()
	     -then reverse one word at a time. use 
	     - while(end = s.find(" ",start) != string:npos)
			reverse(s.begin()+start,s.begin()+end)
			start= end+1;
	     -reverse(s.begin()+start,s.end())


3. RunLength Encoding/Decoding
--------------
	aaabbbc= 3a3b1c
	- Use a second string to copy the results over. like this : results += 
	- to_string(integer) and is_digit(char)
	
	
	
4. Character substitution and removal
---------------
      Eg. replace a with dd and remove all b

	-First pass count all 'a', while removing b. Overwrite in the same space.
	- now do s.resize(idx + a_cnt)
	- Then start from the end, and keep moving towards the start replacing all 
           occurences of a with 'dd'

	Remember Amazon Echo price reduction problem. remember to use ostringstream


5. Minimum Window Substring (leetcode 76)
-------------
	Given a string S and a string T, find minimum window in S that contains all the characters in T.
	Example:
	Input: S = "ADOBECODEBANC", T = "ABC"
	Output: "BANC"

This is a two pointer solution where you keep moving right pointer until you find a substring that contains all characters of target. Once that happens, you have to start moving left pointer thereby shrinking the substring window to find min substring(if it exists) until you find a substring that doesn't contain all target charcters. 
Now, stop moving left pointer, return the new left pointer and start expanding right pointer again and repeat the process.

To know whether a substring contains target characters, we need two maps. Target will be map<char,int> and substring  will be unordered_map<char,int> 
- Run a forloop for endIndex.
- If character is found in target, save that index in vector, call doesWordContainTarget(targetMap,wordSoFarMap).
	If yes, call checkForTargetInWordSoFar() where the left pointer loops goes through values stored in vector.


6a. Permutation in String (lc 567):
---------
- Here, we use two hashMaps and compare their counts for anagram match.
- Take the first len1 letters in s2, store in s2 and check for anagram. If not, keep moving window to the right by 1 , check for match  until you hit end of s2.


6b. Find All Anagrams in a String (LC: 438)
---------
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
Input:
s: "abab" p: "ab"

-  We store the characters of the target string in hashMap. and also compute the targetSum but adding the integer values of all the characters in targetString
-  Its a valid anagram match when hashMap.count() returns TRUE for every character AND the computedSum=targetSum.
- PLEASE REMEMBER: Use only one hashMap, not two. Use just the start position for checking anagram against pattern. Don't do windowing approach and move the window as in Problem 6a.
-  Once you find anagram, start a loop and check to see if the character to be added next equals first index of the current anagram. If so, keep moving to the right until you find a non-match. 
- Non-match could be of two kinds:
	- The hashmap didn't contain the character at the next Index. In that case, move the loop Index to the next index.
	- Hashmap contained the character at next index, but the outgoing character didnt match the incoming character. In that case, just increment the index by 1.


7. Longest Palindrome substring (lc 5):
-------
 - KEY TAKEAWAY: For each index, check oddPalindrome and evenPalindrome across the entire length of input string 
 
 - This is O(N^2). 
 - Outerloop is to go through each index. 
-  Inner loop will expand outwards from that index on both sides. Handle odd and even palindromes for every index.
	- For odd case, start with given index.
	- For even case, think of starting point as between current index and previous one. Makes it easy to visualize

8. Big Integer Multiply (lc 43):
- KEY TAKEAWAY: Use a hashMap<int,vector<int>> and stack. hashMap key corresponds to the column whose values need to be added 		to get final sum (here, first col is 4+0+0). Prefix number of zeros before you start populating the row.
	E.g. 444*111 =   
		 444
	        4440
	       44400 
    - Handle carry outside the loop for both multiply and then final summation operations.
    - Use stack to store the final sum by *iterating (yes, iterating ) through hMap index and pop out the result into string.

9. Reorganize string (lc: 767):
---------
  - Use Priority Queue: Pull two elements from the queue at a time.
  
10. Palindrome with at most 1 removal (lc:680):
----------------
- When you hit a character mismatch, form two substrings by omitting the unequal characters from left and right respectively. If either of them is not palindrome return false.


================================================
      BINARY SEARCH
================================================
LC tutorial:
https://leetcode.com/explore/learn/card/binary-search/136/template-analysis/935/

1) This search is done on sorted arrays. Remember the core algo uses only 1 while loop. no recursion. When you see sorted array, it should typically be binary search.

2 a. To return first element in sorted array with duplicates, the only change is to modify the target<a[mid] check as follows:
	if(target < a[mid] || (target==a[mid] && mid > 0 && a[mid-1]==a[mid])
		high=mid-1;
	else if(target > a[mid])
		low=mid+1
	else
	     	return mid
		
2 b.  Find First and Last Position of Element in Sorted Array(lc: 34)
--------
  - Basically 3 binary searches.
  - Use binary search to locate the element the first. mark both first and last index the same.
  - use above technique for first position. For finding last position, add same logic in right side check


3) To return element closest to a target element (Record and Move-on):
	a) do usual binary search. But for every mid, track min of abs(a[mid]-target)

4) To find minimum in rotated sorted array (all elements unique. If not unique, you have to do O(n) ):
	a) Two key observations: If array is rotated, last element < firstElem. 
		- minimum element is <= lastElem  and 
		- element to left of miniumElement is greater.
	b) key Logic:
	   if (nums[mid] > lastValue) {
                start = mid+1;
            }
            else if(nums[mid] <= lastValue) {
                if (mid==0 || (nums[mid-1] > nums[mid]))
                    return nums[mid];
                else
                    end = mid -1;
            }
	
5) To determine , square root, run binary search with low=2 and high=x/2. And only one change to algo:
	- if (mid*mid < x) { low=mid+1;ans=mid; }

6) To find a peak in a regular array where there can be multiple peaks but no two adjacent elements are equal:
	- Deal with boundary (0 and last element) separately by comparing to its neighbor
	-  You compare the middle element against either side. If middle is greater than its neighbors, return it.
	- else if middle < left neightbor, move binary search to left
	- else If middle < right neighbor, move binary search to right.
	
7) Median of two sorted arrays (lc:4)
	- helper function to handle empty arrays
	- helper function to handle when one array's greatest < other array's smallest
		- here consider 4 comparative cases for : (medianIndex+1) < or ==len1 or ==len1+1 or everything else
	- find the smaller of the (midIndex1,midIndex2). Lets call it target.  
	  In the other array, compute index  whose value <= target using binary search using record and move-on. We call this 
	       newIndex =findIndexLessThanMidValue().
	- Now compute numIndicesToAccountFor. 
	*  If it is zero, you handle is separately 
	*  If it is non-zero,move to right of numIndex1 (& in nums2) storing prev and curr until numIndicesToAccountFor=0
	
8. Find K Closest Elements (lc: 658): very tricky
	- use lower_bound
	- and use windowing approach where left and right are k on each side and they move inward!
	
	
9. Missing Element in Sorted Array (lc:1060): - very tricky
	- See how second variant of binary search is used.

10. Cutting Ribbons (lc 1891):
	- You should know how to use the binary search. It's not always operating binary search on input vector. In this case, binary search is done  on the possible values of answer,whose range is between 1 and (sum of input vector)/k. There's also trick to save the last working value.
	
		
================================================
      PERMUTATION/COMBINATIONS
================================================
The code structure for these problems are generally like this:
	a) run for loop
	b) do some operation, 
	c) recurse (with incrementing index)
	d) undo operation
	e) termination condition at the start
	
- For combination, the comboHelper will do a for-loop with *for-loop-Index* (passed-by-value) getting incremented with every recursive call. 
	- Remember, terminating condition requires checking vector size()
	for(...){
		vector.push_back();
		comboHelper(forloopIndex+1,...)
		vector.pop_back();
	}
	
- For permutation, we use swap, not push/pop . The helper will do a for-loop with *main index* (passed-by-value) incrementing with every recursive call.
	- Remember , terminating condition is to see if mainIndex has reached input size.
	for(i=mainIndex; .. ;..){
		swap(nums[mainIndex],nums[i]);
		permuteHelper(mainIndex+1,...)
		swap(nums[mainIndex,nums[i])
	}
- For permutation with duplicates, same as above only difference is to sort the vector first, and skip duplicates before recursion.
	-  sort(v.begin(),v.end());
	-  call helper(index,...)
	-  helper :
		for(i=mainIndex; .. ;..){
			if(i!=index && nums[i]==nums[index]) skip;
			swap(nums[mainIndex],nums[i]);
			permuteHelper(mainIndex+1,...)	
		}
		
- In coinSum, to print all combinations, it's just the same as combinationSum where 
----------
	 for coins loop {
	     vector.push_back(coins[i])
	     recursive call (with same forLoopIndex,sum+coins[i])
	     vector.pop_back()
	 }

- Refer to powerSetsCombinationPermutationsCoinSum.cpp for actual code
- Time complexity: Exponential. How? https://stackoverflow.com/questions/13467674/determining-complexity-for-recursive-functions-big-o-notation

================================================
DYNAMIC PROGRAMMING
================================================

1) Fewest coins to make up that change ( lc:322):
-------------
	  Equation: 
	  	ans[i] = 1 + ans[i-c]; //first pass
		min(ans[i], 1 + ans[i-c];). //subsequent passes
	- vector<int> ans(amount+1,-1);
	- Initialize ans[0]=0;
	- Outer loop is always coins.
	- Inner loop runs from coin to amount inclusive
	- Create a vector of upto length "amount"+1.
		
		
2) Total number of ways to make the change (lc: 518):
----------
	Equation:
	ans[k] = ans[k] + ans[k-c];

	- Initialize ans[0]=1; // Answer vector is from 0 upto the amount. It indicates how many ways for each of index
	- Outer loop is always coins.
	- Inner lopp runs from coin to amount inclusive
	- Create a vector of upto length "amount"+1.
	- In the inner loop, runnig throuygh ansqer vector from 1 to k. you compute ans[k] for first coin, then goto second  
	   coin and add cumulative sum and so on.


3)  01 Matrix: Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1 (lc:542)
-----------
You make a first pass top-to-bottom, left-to-right : finding min against left and top neighbor(remember that [0][0] cant be computed)
  if(i>0)
	ans[i][j]=min(ans[i][j],1+ans[i-1][j]);
  if(j>0)
	ans[i][j]=min(ans[i][j],1+ans[i][j-1]);

You make a second pass bottom-to-top, right-to-left : finding min against right and bottom neighbor(remember that  [m-1][n-1] cant be computed)
if(i<m-1)
  ans[i][j]=min(ans[i][j],1+ans[i+1][j]);
if(j<n-1)
  ans[i][j]=min(ans[i][j],1+ans[i][j+1]);
  
 https://leetcode.com/discuss/general-discussion/475924/my-experience-and-notes-for-learning-dp
  

================================================
RECURSION/BACKTRACKING
================================================

1) Maze Problem:
========
- UniquePaths in MxN = (UniquePaths in MxN-1) + (UniquePaths in M-1xN)
- Need to use ordered map<pair<int,int>,int>.
- Terminating condition: if (m==0 || n==0) , return 1;
- Now if they ask you to print all the paths, you can't use the above logic. Then, start from (0,0). Every time you make a call to right or down, push_back  R or D to a vector and recurse. When you reach (row==m-1 && col==n-1), increment ans, and also push the vector to vector<vector>

1 b) Maze with obstacles
===========
- when you have obstacles, you'll have three if conditions for recursion. 
     a) upper row blocked, left col not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m,n-1, mMap);
     b) left col blocked, upper row not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap);
     c) upper and left unblocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap) + uniquePathsWithObstacles(grid, m,n-1, mMap);
	  
- Handle m==0 and n==0 by saving & returning 0 when blocked	

	Other easy solution: https://leetcode.com/problems/unique-paths-ii/discuss/23248/My-C%2B%2B-Dp-solution-very-simple!

2) N-Queens Puzzle (lc: 51)
=======
Important Aspect: 
	code  structure is just like combinatorial recursion problem : 
	a) run for loop b) do some operation,  c) recurse (with incrementing index) d) undo operation
	
- Here, rowIndex is incremented by 1. And we recurse only if we placed the queen
- For each row, we loop thru all columns placing Queen after column, left diagonal & right diagonal conditions are met. 
- The line after recurse will reset the position of Q  so that we could find new positions.

	bool isValidPos(vector<string>& ans, int i, int j,int n) {
		if(!isQueenInColumn(j,ans)&&  !isQueenInLeftDiagonal(i,j,n,ans) && !isQueenInRightDiagonal(i,j,n,ans)){
			ans[i][j]='Q';
			return true;
		}
		return false;
	}
	
	void helper(int n, vector<string>& ans, int rowIndex,vector<vector<string>>& vv) {
	  <insert Termination condition here>
         for(int j=0;j<n;++j){
            if(isValidPos(ans,rowIndex,j,n)) {
                ans[rowIndex][j]='Q';
                helper(n,ans,rowIndex+1,vv);
                ans[rowIndex][j]='.';
            }
         }
    }


 3) Word Break Problem (lc:139)
 ========
 Input = "ilikemangotango"
Output: 
"i like mango tango" 
"i like man go tan go" 
"i like mango tan go" 
"i like man go tango"

Important aspect: Refer to the video link
https://www.youtube.com/watch?v=hLQYQ4zj0qg


2 recursive call for every index and hashSet indicating whether a word was at the index.

- Grab substr at every index:
- You need a hashSet<int> to keep track of whether a word was found at that index i. This is to pop the word and continue forming next bigger word
- For a given index, if word found from input hash set, add it to wordVec and update hashSet at this index. 
	- If this is last word of input sentence, add it to ans. 
	- Else recurse with next index and length set to 1 : 
		helper(s,hSet,str,index+len,1,ans,wordFoundPos,wordVec);
- For the same index, if hashSet<int> indicates there was a word there,  pop the word and clear the hashSet field
-  Recurse to include next index to form larger word .
        helper(s,hSet,str,index,len+1,ans,wordFoundPos,wordVec); 
- Code here: https://leetcode.com/submissions/detail/253027047/ 

4) Pow(x, n)  (lc:50): Plain recursion:
=========
    double myPow(double x, int n) {
        if (n==0) return 1;
        double t = myPow(x,n/2);
        if (n%2) {
            return n<0 ? 1/x*t*t : x*t*t;
        } else {
            return t*t;
        }
    }
    
    
    
    
================================================
     3 .  LINKED LISTS
================================================

Start with 3 node link list for fast-slow pointers.
A. Append Function : 
------------------------------------------------
Write append function of List class that can be re-used. You need to know tail to write this fuction. 
This function will be useful in many problems especially when sorting a list containing subset of values 
(e.g. 1,2,3 where you create 3 heads and 3 tails for each value  and  then result list where the 3 lists are 
appended one after  another. Note you are re-using the nodes and not creating new copies. 
Refer to interviewcamp for clarification)


B. Detect Cycle in Linked List (this logic is important. Notice the if loop part is identical to while loop logic):
------------------------------------------------
slow=head; 
fast = head;
while(fast!=null){
	fast=fast->next;
	if(fast==slow)
		return true; //cycle exists
	if(fast!=null){
		fast=fast->next;
		if(fast==slow)
			return true;
	}
	slow=slow->next;
}
return false;


Better Approach:
=====
take 1 thru 6 nodes and make 6th node point to 3 node
ListNode *detectCycle(ListNode *head) {
        if(!head)
            return NULL;
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast && fast->next){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow){
                break;
            }
        }
        if(!fast || !fast->next)
            return NULL;
        fast=head;
        while(fast!=slow){
            slow=slow->next;
            fast=fast->next;
        }
        return slow;
        
    }
    
    

C. Length of Cycle in List:
------------------------------------------------
Once you determine fast meets slow, exit the loop, move fast 1 node at a time until it meets slow again. Compute the length


D. Where Cycle starts in a List
------------------------------------------------
Detect a cycle, then find the length of the cycle L. Once you know the length of the cycle, reset fast and slow back to head of the list. Then,  move fast node forward by L nodes. Now, advance both pointers by 1 until they meet. The node at which they meet will be the start of the cycle.


E. Reversing a list (lc: 206)
------------------------------------------------
	-Use prev = NULL, curr = root ; one_ahead=curr->next; Compute one_ahead
	- Compute logic using a  middle node with node on either side. And extend it for first node
	- return prev.
	- If you have to reverse using recursion, use a helper like this:
		 void recurseReverseList(ListNode* currNode, ListNode* prevNode, ListNode** rootNode){
			if(currNode==NULL){
			   *rootNode = prevNode;
			   return;
			}
        		recurseReverseList(currNode->next, currNode, rootNode);
       		 	currNode->next= prevNode;
   		 }
		 
	  Don't forge to initalize rootNode = &head and call
	   	recurseReverseList(head, NULL, rootNode);
	  
	  
F. Merge Sorted Lists
=======================
	- Relatively straightforward. Figure out the root node first. Set it aside. Keep two pointers, one for each list.
	- while(list1 && list2)
		Pick the minimum.
		
I. Merge k sorted lists (lc 23)
-------
- Find minimum value first. Store that as root node. 
- Use a hashset to store all the head nodes, grab the minumum node, add it to final list,  and then erase the min node and add minNode->next
- while(hashSet not empty){
	walk through hash set and grab the minimum head node from the hashSet and add to final list
   }
   
   
G. Palindrome List
=========
-  Do fast-slow trick to get to middle of the list. Important logic
  Node* fast=head;
  Node* slow=head;
  while(fast->next && fast->next->next){
  	slow=slow->next;
	fast=fast->next->next;
  }
- Now, slow points to middle. Save slow->next as head of second half of list  that you gotta reverse.
- slow->next is then set to NULL
-Once the list is reversed, compare the head and new reversed list node by node for equality
- If second list doesnt return null, it means it's not palindrome! Make sure to put that slow->next back to saved value.

		
H. LRU Cache
======
- Cache is a linked list. It will be list of keys. 
- At any given point, the last element of the list will be the LRU element (ready to be evicted if need be).
- When you read from a cache, that entry is updated to the head of the list if the entry is present. If the entry is not present, you return invalid. 
- When you write to cache, again you update the entry to the head of the list if it exists. If it doesnt exist, you add that entry to the front of the list. If the cache size is full, then you gotta evict the LRU element, which will be the last element of the list bfore adding the element to the front of the list.
- To implement, we need the one STL list and two STL unordered_maps as follows:
	- list<int> cache
	- unordered_map<int, list<int>::iterator> hMap
	- unordered_map<int, int> kvMap;
- We need to implement the following functions:
	- int get(key) : will call updateCache()
	- void put(key,value)   :  will call updateCache() and/or evict()
	- void evict()
	- void updateCache(key)
- Be familiar with C++ STL list.


I. Removing duplicates in a List: O(n^2):
=========
checkDup(Node* root){
	Node* current = root; Node* runner;
	while(current!= null){
		runner = current;
		while(runner.next != null){
			if(runner.next.data==current.data)
				runner.next = runner.next.next
			else
				runner = runner.next
		}
		current = current.next
	}
}

---------------
J. Flatten a Multilevel Doubly Linked List (lc: 430):
---------------
https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/

- Just one recursive call.
- IMPORTANT: Pass endNode pointer by reference to return the last node at child level. 
- Don't forget to reset the child pointer to NULL, after flattening it. 
https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/discuss/459491/0-ms-easy-to-follow-solution-in-C%2B%2B


================================================
     4 .  STACK
================================================

A. Postfix Expression (lc:150)
======
 - Need only one stack<string> for operands. when you encounter operator, you pop two from stack and process it.
 - Use stoi() for computation with operator and to_string() to put it back in stack
 
 
B. Infix expression aka Basic Calculator (with or without paranthesis) (lc:224, lc:227)
=============
- KEY TAKEAWAYS: 2 stacks, assigning priority to operators, handling all operators in stack >= current operator priotity, and processing all operatots until you hit '(' when you encounter ')'

- Set priority value for operators as follows:
	int getOperatorPrecedence(char c) {
        	if (c=='*' || c=='/')
            		return 2;
       		if (c=='+' || c=='-')
            		return 1;
        	else if (c=='(')
            		return 0;
        	else
            	    return -1; //  for ')'
 	}
- if you see operand , put it in the operand stack<int>
- else if when you see '(', put it on operator stack<char>
- else if when you see operator ')', process operand until the operator on the stack is '('.
- else if when you see operator, check to see if the top of operator stack has >= than the current operator. If it does, process operand until the operator on the stack is lower than the current operator.
-  If spaces are allowed, keep storing digits until you hit space and that becomes operand.
Refer to my leetcode solution. You call storeOperand() before virtually every character except digit
- Refer to : https://leetcode.com/submissions/detail/229513107/

C. Exclusive Time of Functions (lc: 636). - Very tricky
-----------
- When you encounter start,  update ans[id], do stack push and store prevTime=currTime.
- When you encounter end,  update ans[id],. do stack pop and store prevTime=currTime+1
- You only have to keep track of prevTime and currTime.


================================================
     5 .  QUEUE
================================================

A. Ring Buffer or Circular Queue (lc:622)
========
- KEY TAKEAWAY:  back = (back+1)%k;front=(front+1)%k; have a length variable to keep track of elements queued/enqueued
- Implemented as array of fixed size where you insert in the back and dequeue from front.
- In the class definition, have a "length" variable that increments with every enqueue and decrements with every dequeue.
- When length==0, queue is empty; when length==k, queue is full.
- enqueue():
	v[back] = value;
	rear=back;
        back = (back+1)%k;
        ++length;
- dequeue():
	v[front]=-1;
        front=(front+1)%k;
        length--;
	

B. Sliding Window Maximum
=========
- Remember any sliding window problem is almost always queue
- use deque because you need to iterate through the queue
- First walk through k values and store the max of those in output vector.
- From then on, loop through remaining input vector one element at a time.
	 - If new element being considered is > prev max, store the new one.
	 -  If element being removed is the max, you gotta find new max then.
	 -  Else retain the lastly added vector value as new max
	 
	 
C. Implementing Max in Queue in 0(1) lookup
=======
Maintain two queues. One regular queue and another deque for storing max. Dequeueing is removing element from front of deque, enqueuing is more subtle. When the element to be added is > back of deque, keep removing all elements from back
until you find element >= current element.


================================================
     7. LineSweep
================================================
The common sequence in most Line Sweep solutions is:
	- break down intervals into Points.
	- sort the points using custom comparator
	- loop through the points
	
	
Merge Intervals (lc: 56):
---------
- Make sure to remove duplicate elements from input vector first
- Created a sorted Point vector using custom comparator for sorting.
- Use count variable that increments for start Point, and decrements for end Point. 
- When count is zero for both start and endPoint, it becomes a legit interval.

Skyline Problem (lc: 218)
------
 Seperate points as startPoints and endPoints. Each point is of the type Point. 
 Sort the points in ascending order based on x-value.
	-For points with same x-value, startPoint comes before endPoint
	- For startPoints/endPoints with same x-value but multiple heights, sort them in descending order.
Walk through the vector of points:
If startPoint:
	If currentHeight>maxHeight, update answer. And heapify height vector.
	Else only heapify height vector
If endPoint:
	Handle duplicate endPoints with different heights first. (More explanation in the code)
	If endPoint height ==currentMaxHeight, remove currentMax and find nextMax from the heap
	else, remove height from heap and heapify.
	
Meeting Rooms (lc: 252,253) : You gotta return min number of rooms given a schedule
-------
   - In the custom comparator endPoint needs to come before startPoint when the values are equal.
   - Increment and decrement count as before. However, when cnt in startPoint exceeds minRooms, you increment minRooms
   	 if(p.start) {
                ++cnt;
                if(cnt > minRooms) 
                    ++minRooms;
          } else 
                --cnt;


================================================
     8. TREES
================================================

A.  Implement InOrder, Pre & Post-order traversal iteratively (lc:145)
-------------
	- Use stack and visited flag. The visited flag is implemented as hashMap<TreeNode*,bool>
	- You pop the node off the stack, check if it is visited,then print. If not, mark it as visited, add the children in 		opposite order.
	- Basically, you add a node to stack unvisited, pop it, add it again as visited, and then pop it to print it.
	- while(stack not empty){
		if(hMap[node])
			print
		else {
		    node->visited=true;
		    now push nodes in reverse of the order asked
		  }
	   }
		    
B. Height Of Tree(i.e. Max Depth of Tree) (lc: 104): 
------
	if(!root) return 0;
	int leftHeight=maxDepth(node->left);
        int rightHeight=maxDepth(node->right);
	return 1+max(leftHeight, rightHeight);
	
	
C. Check Balanced Tree (lc: 110):
------
  - Uses getHeight() as helper function that returns just as above. 
  - This helper also takes bool as reference. We return this bool eventually as final answer. So the final height output is of 	no consequence
  - Compute leftHeight and rightHeight and if difference is > 1, mark bool to be false.
  
  - int getHeight(TreeNode* root,bool& ans){
        if(!root) return 0;
        int leftHeight= getHeight(root->left,ans);
        int rightHeight = getHeight(root->right,ans);
        if(!ans)
            return -1;
        if(abs(leftHeight-rightHeight)>1)
            ans=false;
        
        return 1+ max(leftHeight,rightHeight);
        
    }


D. Longest Path between any two nodes of binary Tree (aka Diameter of Binary Tree) (lc: 543):
-------
 - Almost identical to balanced binary tree implementation except bool& is replaced with int&.
  		int leftHeight=getHeight(root->left,ans);
		int rightHeight= getHeight(root->right,ans);
		ans = max(ans,leftHeight+rightHeight);
		return 1+ max(leftHeight, rightHeight);
 
 
E. LCA of Binary Tree (lc 236):
-------
- tricky yet simple recurison. Store recurse left, store recurse right. Consider the null/non-null output to encode the logic.
- Think of A&B in different combinations with root - A being root;  A&B being root's children; Root has A on left, which has B on left; Root has B on right, which has A on left. These 4 scenarios should help you frame the logic.
	lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	if(!root)
                return NULL;
        if(root->val==p->val || root->val==q->val)
            return root;
        TreeNode* leftNode=lowestCommonAncestor(root->left, p,q);
        TreeNode* rightNode=lowestCommonAncestor(root->right, p,q);
        if(leftNode && rightNode)
            return root;
        else if(!leftNode && rightNode)
            return rightNode;
        else if(leftNode && !rightNode)
            return leftNode;
        else
            return NULL;
	 }

F. Construct binary tree from inorder and pre-order traversal (lc: 105):
------------
 - Loop one by one thru preorder vector. Look for this element in the inorder vector. Inorder index will be pivot.
 - All elements to left of pivot will be in left of the current root. 
 - All elements to right of pivot will be to right of current root.
 - Here I dont check for idx out of bound as the if condition prior to it handles it.
 
	TreeNode* treeHelper(vector<int>& preorder, vector<int>& inorder, int& idx, int start, int end){
		if(start>end)
			return NULL;
		int elem=preorder[idx++];
		int pivot=start;
		while(inorder[pivot] != elem)
			++pivot;
		TreeNode* node = new TreeNode(elem);
		node->left = treeHelper(preorder,inorder,idx,start,pivot-1);
		node->right = treeHelper(preorder,inorder,idx,pivot+1,end);
	    	return node;
	}

  }
  
G.  Invert Binary Tree (lc 226):
 ----------
  - The only thing to remember is that when you recurse and hit leaf node, return the leaf. 
  
  TreeNode* invertTreeHelper(TreeNode* root){
        if(root->left==NULL && root->right==NULL)
            return root;
        TreeNode* leftSubtree = root->left ? treeHelper(root->left) : NULL;
        TreeNode* rightSubtree = root->right? treeHelper(root->right):  NULL;
        root->left = rightSubtree;
        root->right = leftSubtree;
       return root;
    }
    
 H. Level Order Traversal (lc:102)
 ---------
 - There's standard BFS outer-while loop. Then there's inner for-loop for queue size.
 
  void bfs(vector<vector<int>>& ans, queue<TreeNode*>& q){
        while(!q.empty()){
            int sz = q.size();
            vector<int> v;
            for(int i=0;i<sz;++i) {
                TreeNode* elem=q.front();
		q.pop();
                v.push_back(elem->val);
                if(elem->left) 
                    q.push(elem->left);
                 if(elem->right) 
                    q.push(elem->right);    
            }
            ans.push_back(v);
        }
    }
  
  G. Vertical Traversal(lc:314, 987):
  ----------------
  
 - Think of origin as (0,0); Left child is (-1,1), its left child is (-2,-2). Right child of root is (1,1).
 - Use hashMap <x,<y,nodeValue>> with DFS. And use custom comparator for sorting.
 
 
 ----------------
  I. Binary Tree Coloring Game (lc:1145)
  ----------------
  https://leetcode.com/problems/binary-tree-coloring-game/
 Ans:
 - For given node x, count number of nodes to its left (lans), number of nodes to its right(rans). If any one of them is > 50 % of n , return  true.
- Otherwise, goto parent of x. If x is to the left, compute (n-lans) . Else compute (n-rans)
- if (n-lans > lans) OR  (n-rans > rans), return true;
- Otherwise false.


----------------
J. Delete nodes and return forest (lc: 1110)
 ----------------
https://leetcode.com/problems/delete-nodes-and-return-forest/

- Recursion problem. Study the problem by traversing to the last node. Use toDeleteSelf and toDeleteChild flags
- If node is to be deleted, return true.
- At the parent, you have two combinations to consider:
	 a) if(!toDeleteSelf  AND toDeleteChild)
		node->child = NULL
	 b) if(toDeleteSelf  AND !toDeleteChild)
		add child to output.

----------
H. Count Tree Nodes of Complete Binary Tree (lc:222)
-------------

if(!root->left && !root->right)
      return 0;
if(root->left)
    lans = 1+countNodesHelper(root->left);
if(root->right)
    rans = 1+countNodesHelper(root->right);
 return lans+rans;
		
		
================================================
      9.  BST
================================================
- At times Helpful to write a successor (leftmost on right) and predecessor function (rightmost on left)

A. Checking if tree is BST (lc:98)
------------
	if(!root)
            return true;
        if(root->val <= minVal || root->val >= maxVal)
            return false;
        return (isValidBSTHelper(root->left, minVal, root->val) && isValidBSTHelper(root->right, root->val, maxVal));

B. INSERITION of KEY IN BST:
------------------
parent=NULL; curr = root.
keep moving left or right until curr = NULL.
check whether node needs to be right or left of parent.


C. DELETION of KEY IN BST (lc: 450)
--------------
-  No helper needed
 - Remembert how to recursively traverse left of right until you the node to delete.
 - Once you find the node to delete, 
 	- if it's leaf node, just delete(root).
	- if it has left or right but not both, just  root=root->left (or root->right).
	- if it has both left&right, find BST-successor,substitute its value, and recurse until you hit that successor value.
 TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return NULL;
        if (root->val > key) {
            root->left = deleteNode(root->left, key);
        } else if (root->val < key){
            root->right = deleteNode(root->right, key);
        } else {
            if (!root->left || !root->right) {
                root = (root->left) ? root->left : root->right;
            } else {
                TreeNode* rightMin = root->right;
                while (rightMin->left) rightMin = rightMin->left;
                root->val = rightMin->val;
                root->right = deleteNode(root->right, rightMin->val);
            }
        }
        return root;
    }
 
D. First occurence of a key in a BST 
---------------
- Use record and move on.
	while(root!=NULL)
 		- If root < key, move right, 
		- if root > key , move left
  		- If root==key, result=root, root=root->left;


E. Inorder Successor in BST (lc: 285)  (please remember: no need of a hashmap here)
-------------------------------------------------------------
- Check if p has right node, find leftmost on right of p.
- If not, make current=root, parent=NULL.
	while(current!= NULL)
		- If current < target, just move right
		- If current > target, save parent=current, move left.
		- if current==target,break and return parent.


F . LCA of BST (lc:235)
----------------
  while(root){
        if(p->val < root->val && q->val < root->val)
            root=root->left;
        else if(p->val > root->val && q->val > root->val)
            root=root->right;
        else {
            ans=root;
            break;
        }
    }


G. Convert Sorted Array to BST (lc:108)
------------------
TreeNode* treeHelper( vector<int>& nums, int left, int right) {
        if(left > right)
             return NULL;
        int mid = left + (right-left)/2;
        TreeNode* node = NULL;
       if (left<=right){
            node = new TreeNode(nums[mid]);
            node->left = treeHelper(nums,left,mid-1);
            node->right = treeHelper(nums,mid+1,right);
        }
        return node;  
}


H. Convert sorted list to BST (lc: 109)
----------
- Logic similar to sorted list.  Just observer the terminating condition.

    TreeNode* recurseTree(ListNode* head, ListNode* endNode) {
        if(head==endNode)
            return NULL;
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=endNode){
            fast=fast->next;
            if(fast!=endNode){
                fast=fast->next;
                slow=slow->next;
            }
        }
        TreeNode* node = new TreeNode(slow->val);
        node->left = recurseTree(head,slow);
        node->right = recurseTree(slow->next,endNode);
        return node;
    }


G. Convert Binary Search Tree to Sorted Doubly Linked List (lc: 426) - kinda tricky
	- Routine Inorder recursive traversal with head and tail nodes as global variable. 
	- Update head once, and update tail every time in the "visit(node)" part.
	- Update head->left and tail->right in the main() as well at the end. 
	
	
-------------------------------------------------------------
K LARGEST ELEMENTS IN BST:
-------------------------------------------------------------
Create a vector to store the K elements.
Call Helper function passing in vec, k and root
Check tree for null and recurse all the way to the right.
Check vector size before pushing tree->data and recurse left by calling tree->left.
Remember to check the size of vector before making a call to right, and left


================================================
	10. TRIE  (lc: 208)
================================================
												  
-  Used for auto-complete, and string storage for games like boggle where you choose a valid path based on trie traversal.
- Think of storing words starting with same letter such as dog,dig,dot,dote,deck. You store d at first level; e,i,o at 2nd level etc.
- For implementation, think of tree implementation where each child node is a Tree. Likewise, each node at a given level is Trie accessed using hashmap[char] stored at its parent level. 
- Remember to start with Trie* node = this, and keep re-assigning values to node

class Trie{
	Trie(){
        	neighbors={};isWord=false;
    	}
	
	void insert(string word) {
        	Trie* node = this;
        	for(auto& c: word){
            		if(!node->neighbors.count(c))
                		node->neighbors[c]=new Trie();
            		node = node->neighbors[c];
        	}
        	node->isWord = true;
   	 }
	 
	bool search(string word) {}
	bool startsWith(string prefix) {}
 private:
        unordered_map<char,Trie*> neighbors;
        bool isWord;
}

================================================
	11. GRAPHS
================================================
- Can be represented as edge list, adjacency list,adjacency matrix
	https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs
 - Time: O(V+E) .  Space: O(V)  for most graph problems
 - Keep track of State={VISITED, UNVISITED,VISITING} only when necessary
 - Topological sort is DFS + stack push  at the end.
 
 A. DFS:  
 ------
 
 dfs(Node* node){
	processNode;
	node->state=VISITING;
	for(auto& n: node->neighbors){
		if(n->state==VISITING)
			set ans=false;return; //this is a cycle.
		if(n->state==VISITED)
			continue;
		if(n->state==UNVISITED) 
			dfs(n);	
		if(ans==false)
			return;
	}
	node->state=VISITED;
  }


B. BFS:
------
 - Needs a queue. When you get inside the bfs function, start with while loop for queue
 
q.push(node);
bfs(Node* node, queue<Node*> q){
	while(!q.empty()){
		Node* node = q.front();
		q.pop();
		processNode;
		node->state=VISITING;
		for(auto& n: node->neigbors){
			if(n->state==VISITING)
				set ans=false;return; //this is a cycle.
			if(n->state==VISITED)
				continue;
			if(n.state==UNVISITED)
				q.push(n);	
		}
		node->state=VISITED;
	}
 }

C. Cloning a graph (lc: 133):
--------
- Use DFS. No state variable needed
- You only need a hasMap<OriginaNode*,ClonedNode*> to know whether a given neighbor has been already cloned or not.

    unordered_map<Node*,Node*> origToCloneMap;
    Node* dfs(Node* node){
        Node* clonedNode = new Node(node->val,{});
        origToCloneMap[node]=clonedNode;
        for(auto& n: node->neighbors){
            if(!origToCloneMap.count(n) )
                clonedNode->neighbors.push_back(dfs(n));
            else
                clonedNode->neighbors.push_back(origToCloneMap[n]);
        }
        return clonedNode;
    }


D. Word ladder (lc: 127)
------
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog"

- use BFS. It will have outer while-loop for queue and inner for-loop for queue size.
- Convert wordList to hashSet. When you pop the word from queue, delete it from hashSet.
- From hashset, every 1 char different neighbor, add it to queue. Increment length.

E. WordLadder-II (lc: 126)
----------
  - Everything just as WordLadder-1 except:
  	- when you hit the endword, you set endFlag=true. And you store the results in unordered_multimap.
  	- At the end of current queue, you check for endFlag=true and call reTracePath recursively going backward from endWord until you hit begin word.


F. Longest Increasing Path in a Matrix (lc: 329)
-------
- This can be solved using DFS. This DFS returns integer but only at the very end.
- We use 3 hashMaps:  1) state, 2) storing neigbors, 3) results
- Please remember to store the result for already calculated index in hashMap.
-Use localMax to store the max value  for each index
- Every element has unique index in the hashMap calculated using  ( i* NUMCOLS+ j)


G. Network Delay Time (lc: 743)
----------
https://leetcode.com/problems/network-delay-time/
Key are:
- Djikstra's shortest path algorithm (https://www.youtube.com/watch?v=pVfj6mxhdMw)
- Use of priority queue.

When you use Djikstra's algorithm, you gotta always pick the next node with least cost. To do this we need to have priority queue. Understand how priority queue is used with pairs .


H. Accounts Merge( lc: 721):
========
	- Use DFS. Remember to form the graph first using hashMaps. And use State enum.
	- To learn union-find

G. Bipartite Graph (lc: 785)
------
A graph is bipartite when it has odd number of cycles. Or  in  2color scheme, the neighbor of a node is not of the same color as parent.
- Do BFS with color vector. Use -1 for uninitialized, alternate 0 and 1. Use it as colors[neighbor] = !colors[node].



================================================
	TOPOLOGICAL SORT
================================================

A. Course Schedule aka Toploogical Sort (lc 207,lc 210)
------
- Toplogical sort is  DFS + 1 extra line  at the end, which is stack.push(node) . Then pop out stock to get the right order.
- Topological sort only works when there are no cycles. Therefore it works only for directed graphs.
- IMPORTANT: Remember the order of nodes is important. Prereq node will make have dependent as its neighbor
- To solve Course Schedule :
	- unordered_map<int,State>:  to store states for each node
	- a vector of vertices - one per node. This is populated at the same time states are initialized for each node
	- IMPORTANT: Ensure the false is percolated all the way up for recursive DFS calls.


G. Alien Dictionary (lc: 269)
-------
Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"

- mark all characters of all words as  unvisited in "State hash map".
- You take words in pairs and find the first character tin both that differ. Make the second word's character the neighbor of first word's character. Repeat this for every input pair. This happens in "neighbor hashmap".
- Then run through all the elements in the state hash Map. If the element is unvisited, run dfs on it watching for cycles.


================================================
	HEAP
================================================

- Heap is a Complete Binary Tree (elements at last level will aligned to the left) with parent < two children (for min heap)
- Min heap has lowest element at top  where every parent is less than its 2 children.
- Heap elements are stored in array in level order traversal.
- For element at array index i: 
	- Left child would be at 2*i + 1
	- Right child would be at 2*i + 2
	- Parent will be (i-1)/2
- To insert a new element
	- insert at the very bottom, keep swapping with parent until its value < parent (for a max heap)
- To delete max element
	- remove the max and move last element into the top position. 
	- Now take max(parent,left,right). If parent is not max, swap parent and max element. Repeat this for new max index


================================================
					RECURSION
================================================

TOWER OF HANOII
-------------------------------------------------------------
The key observation is move e all other rings (n-1) except base ring src peg to helper peg.
Then you push base ring to the destination peg.
Push n-1 rings back from the helper peg to the destination peg.

Do this until n>0


B. 
------------------------------------------------
MERGING TWO LISTS
------------------------------------------------
	-Create a shared pointer to new dummy_node, and have a 'tail' point to it.
	-call MergeNode(&lowestValueNode,&tail) when both lists have non-NULL nodes .
	Plese make sure you pass pointers to shared pointers.
	- Make tail point to non-NULL node once you are out of MergeNode()
	-return dummy_node->next;


	

------------------------------------------------
DICTIONARY ORDERING
------------------------------------------------
- The  very last element of the dictionary order is all elements in descending order

- So look for case when a[k]> a[k+1] and all after k are in descending order
- pick the element from the descending order higher than a[k]. Swap it
- Reverse the descending ordered part, i.e. after a[k]



BIT MANIPULATION:
===============

- use XOR primarily. It can be used in conjunction with AND , OR and other techniques etc.
- To get the rightmost bit set in a binary number X,  we use X & (-X)
- Remember binary addition of A and B without + uses Full Adder implementation (https://www.electronics-tutorials.ws/combination/comb_7.html)
	- To add A,B and CarryIn, we do the following:
		Sum =  A xor B xor CarryIn
		CarryOut = (A and B) OR ((A xor B)and Cin))
- When you have negative numbers, use right shift to extract the rightmost bit.



RESERVOIR SAMPLING:
=============
https://gregable.com/2007/10/reservoir-sampling.html
Reservoir sampling is a family of randomized algorithms for choosing a simple random sample, without replacement, of k items from a population of unknown size n in a single pass over the items.The size of the population n is not known to the algorithm and is typically too large for all n items to fit into main memory
Core algorithm:
"The algorithm works by maintaining a reservoir of size k, which initially contains the first k items of the input. It then iterates over the remaining items until the input is exhausted. Using one-based array indexing, let i>k be the index of the item currently under consideration. The algorithm then generates a random number j between (and including) 1 and i. If j is at most k, then the item is selected and replaces whichever item currently occupies the j-th position in the reservoir. Otherwise, the item is discarded. In effect, for all i, the ith element of the input is chosen to be included in the reservoir with probability k/i. Similarly, at each iteration the jth element of the reservoir array is chosen to be replaced with probability  1/k * k/i = 1/i. It can be shown that when the algorithm has finished executing, each item in the input population has equal probability (k/n) of being chosen for the reservoir:  k/i * (1-1/(i+1)) * (1-1/(i+2)) * (1-1/(i+3)) ...* (1-1/n)=k/n"

A.  Random Pick Index (lc:398)
-----------------
In this case,  Reservoir sampling allows us to choose any number uniformly at random from the list of n numbers.


Look at the  LC solution to follow how it is implemented. Basically, you loop through the input array and at every iteration, you check to see if target is found. If it is , you then you do a ( rand()% num of occurrences of target so far ==0) to return the index.

More Explanation:
Each loop you are incrementing the count of possible indices. So if the array was (1, 1, 1) and the target was 1 then
Loop 1: Rand could return 0 (100%)
Loop 2: Rand could return 0 or 1 (50%)
Loop 3: Rand could return 0 or 1 or 2 (33.33.. %)


B. Random Pick with Weight (lc: 528)  : Based on prefix sum and binary search
--------------------
 


UNION_FIND 
=======

https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf

Find: See if two elements are in same set, check if there's a path between two network nodes, check if nodes are connected etc.
Union: Merge two elements to form one set: Add  a connection between grid points etc.

The idea here is that there's an "id" array that stores who the parent of the current node is. That parent is modified with every pass through the nodes N.
As you find the parents, it results in a tree that grows in depth. To optimize for it, we use "weighted-union", where tree with lowest depth is added to tree with greater depth. And then we do "path compression", where we set parent of a given node to its grand-parent.

Here's how it works:

For N nodes:
vector<int> id(n,0); //parent vector
vector<int> sz(n,1); // size vector

Initialization
------
for (int i=0;i<n;++i){
    id[i]=i;
    sz[i]=1;
}

Find
----
  int root(int i){
 	while (i!=id[i])
	   i=id[i];
	return i;
  }
  // another variant for path compression (make every examined node in the path point to its grandparent)
  int root(int i){
 	while (i!=id[i]) {
	   id[i]=id[id[i]];
	   i=id[i];
	}
	return i;
  }
  
  
  bool find(int p, int q){
  	return root(p) == root(q);
  }
  
 Weighted Union with Path Compression 
 ----
 bool union(int p, int q){
 	int i=root(p);
 	int j=root(q);
 	if(sz[i]<sz[j]){
 		id[i]=j;
		sz[j] += sz[i];
 	} else {
  		id[j]=i;
		sz[i] += sz[j];
	}
}

Big O complexity: M union-find operation on a set of N objects: (M+N)log N



Minimum Spanning Tree (MST) using Kruskal's algorithm 
=================

A spaning tree means all vertices need to be connected. The spanning tree with lowest sum of edges is a MST
The idea is that for an undirected graph with V vertices and E edges, there exists MST
Union-Find is used here

GREEDY ALGORITHMS
========

Find a celebrity (lc:277)
---------
- Has a nice elegant solution in O(n). My solution had worst case O(N^2)
- Pick candidate=0. There are two for loops
- In first loop, you filter down to one candidate as possible celebrity
- In second loop, you ensure whether that candidate is celebrity or not. 


665. Non-decreasing Array

https://leetcode.com/problems/non-decreasing-array/



OVERLAPPING INTERVALS ALGORITHM
==============================

Interval A = [leftA, rightA]
Interval B = [leftB, rightB]
Overlapping region:  [max(leftA, leftB) , min(rightA, rightB)]                 
which means if(max(leftA, leftB) < min(rightA, rightB)), there is an overlap.

Problem 836: https://leetcode.com/problems/rectangle-overlap/discuss/185809/Template%3A-Interval-Overlapping
Problem 986: https://leetcode.com/problems/interval-list-intersections/


TIC-TAC-TOE
====
Problem 348,  Problem 1275
- Use hashMaps for each player's row and columns, and counter  for diag and reverseDiag
	https://leetcode.com/problems/design-tic-tac-toe/discuss/1526502/Short-and-simple-easy-to-follow-20-ms-solution-using-hashMaps
- The listed solution from LC is amazing as well
