
================================================
    ARRAYS
================================================

 Array tricks to explore
---------------------------------------
- Having a separate index from loop index.
- See if you can traverse from end to front instead of regular front to end.
- See if you can have start and end pointers and move towards the middle.
- Using dutch national flag.
- See if you can start from middle and expand outwards.

- For Stock Buy and Sell :
	- remember to store minSoFar if only 1 transaction is allowed.
	- For multiple transactions,keep taking successive diffs and adding it to sum if diffs > 0
	- if only 2 transactions are allowed, it's lot more complicated.

- Rotaing an array k times (LC:189): 
	Use three reverse calls just as in sentence reversal. use k=k%sz for k> sz 

 2-D Array
------------------------

- RotateImage 
	Reverse() followed by swapping i,j


- Set Matrix  Zeroes (lc 73):
	- to delay the row manipulation until you get to row below by using two flags:clearCurrentRow and clearPreviousRow.
	- If you encounter zero for a column, zero out only columns above. 
	- If column above has value zero, set current element to zero
	- Handle last row using clearPreviowRowFlag


- Diagnose Traverse of 2D matrix (lc 498):
	- Only two movements to consider: Diagonally downward to the left, OR Diagonally upward to the right.
	- Diagonal motion is where row is increased by 1 and col is decremented by 1 or vice-versa
	- When you hit top row, you either move to right or if you have reached last col, move down
	- when you hit leftmost col, you either move down or if you have reached last row, move right.
	- Exit the loop when you getto the last element.
	
	
- Spiral Traverse (lc 54):
	- Only three things are needed: matrix size (mxn), startRow, startCol
	- For every new iteration: 
		m -= 2
		n -= 2
		startRow +=1
		startCol +=1
	- 4 for-loops for every (m,n) pair.
	- IMPORTANT:  In the 3rd and 4th for-loops, do extra checks in for-loop initialization itself to make sure we are not 		traversing the same row, col. This is to handle 1 row,1 col case.
	
	
- Search in Sorted 2D Matrix (lc 248)
	- Start with top rightmost element . Lets call it e.
	- If target==e, return true;
	- If target<e; --col;
	- If target>e; ++row;
	Do this while(row<m && col >=0)
	
	
========================================================================================
Longest Substring Problems (sliding window)
========================================================================================
 - General idea is to use hashMap<char,int> and compute sliding window of size as (i-startIndex+1). 
 - Key is to figure out what to store in hashMap  and when to shrink/expand the window 
 - Most of these problems are O(n).
 - Be VERY, VERY CAREFUL about when to use inner while loop vs if loop
 
1.  Longest Substring Without Repeating Characters (lc: 3 and educative)
-----------
	The key aspects are:
		- hMap[s[i]]=i; //storing the index where the char was last found
		- When you hit a duplicate char, update startIndex = max(startIndex,hMap[s[i]]+1)
		- maxLength=max(maxLength, i-startIndex+1);


2. Longest Substring with Same Letters after at most k Replacement (lc 424 and educative): Very tricky
-------------

We’ll iterate through the string to add one letter at a time in the window. We’ll also keep track of the count of the maximum repeating letter in any window (let’s call it maxRepeatLetterCount). So at any time, we know that we can have a window which has one letter repeating maxRepeatLetterCount times, this means we should try to replace the remaining letters. If we have more than ‘k’ remaining letters, we should shrink the window as we are not allowed to replace more than ‘k’ letters."
     The keys are:
     	- hMap[str[i]]++;
        -  maxLetterLength=max(maxLetterLength, hMap[str[i]]);
        - if(i-startIndex+1 - maxLetterLength > k){
                hMap[str[startIndex]]--;
                ++startIndex;
            }
	 - maxLength=max(maxLength, i-startIndex+1);


3. Longest Substring with At Most K Distinct Character (lc 340)
---------------
    - Here, if the hashMap size > K for a given window, shrink the window until map size <= k. So, the key points are:
      while(hMap.size() > k){
	hMap[s[startIndex]]--;
	if(hMap[s[startIndex]]==0)
	    hMap.erase(s[startIndex]);
	++startIndex;

      }
      maxLength=max(maxLength, i-startIndex+1);




============================================
SUB-ARRAY SUMS
============================================
 - General idea for sub-array sums with successive elements is to have runniung sum and use hashMap<int,int> that stores sum in some fashion.  
 - Most of these problems are O(n).
- Remember: At given index: sum - (sum-k) will result in target k


1: Maximum Subarray (lc: 53)
---------
To determine max sum in array with  +ve & -ve, you have to determine local max at every index and use that to compute global max at every index. Return global max.


2: Subarray Sum Equals K: To determine *NUMBER* of subarrays that sum to K (lc: 560)
-----------
	- KEY Understand that at given index: sum - (sum-k) will result in target k. So the goal is to know whether sum-k was 	     seen earlier and if so, how many times:
		 if(hMap.count(sum-k)) 
		 	ans+= hMap[sum-k];
		hMap[sum]++
	- Don't forget hMap[0]++
	
	
3: To check if the NON-negative array has a continuous subarray of size at least 2 that sums up to a multiple of k (lc: 523)
--------------
 	Key: Remember remainder theorem: (A+(n * k)) % k = A%k.
  	a) hMap[0]=-1;  //to handle the case [0,0]
        b) runningSum %= k;  //when k!=0
        c) if(hMap.count(runningSum)){
                if(i-hMap[runningSum] > 1)
                    return true;
            }
            else //to handle [0,0]
                hMap[runningSum]=i;
 
 
 4. Smallest Subarray Of Positive Integers with sum >= K (lc:209, educative):
 ---------------
 	Here you dont need hash. Keep adding till sum >= K. then shrink sliding window until sum becomes < k. Move forward.
	
	
	
 5. 3 sum or  4 sum problem where any a+b+c=target in a given array, it follows a different pattern as follows (lc: 15,16,18)
 	- sort the vector first
	- Outer for-loop runs the lenght of vector.
	- Last two nums will be taken from start and end of the vector converging inwards in a while loop
		 for(i=0;...){
		 	newTarget=target-nums[i] ; j=i+1; k=nums.size()
		 	while(j<k) {
				if(nums[j]+nums[k] < newTarget)
					j++;
				if(nums[j]+nums[k] > newTarget)
					--k;
				else (nums[j]+nums[k]==target)
			   		store the values, eliminate duplicates for nums[j] and nums[j] using two while loops
		  	}
			another while loop for eliminating duplicates of nums[i]
		   }
		 
 	
	
================================================
    STRINGS
================================================

KEY TAKEAWAYS:
- To know if a substring characters is part of another bigger substring, put target word as map and word-to-check in hashMap and just compare the counts
- To know if the word is anagram of another,  put the chars in hashmap and also keep track of the sum of all chars.
- To know if string B is rotated version of A, look for A+A.find(B) provided lengths are same

1. Palindrome string
-----------
	-Two indices: at start and end. 
	- Use isaplhanum() and tolower()


2.  Reverse sentence
------------
	3 calls to reverse()
	     -Reverse the whole sentence using reverse()
	     -then reverse one word at a time. use 
	     - while(end = s.find(" ",start) != string:npos)
			reverse(s.begin()+start,s.begin()+end)
			start= end+1;
	     -reverse(s.begin()+start,s.end())


3. RunLength Encoding/Decoding
--------------
	aaabbbc= 3a3b1c
	- Use a second string to copy the results over. like this : results += 
	- to_string(integer) and is_digit(char)
	
	
	
4. Character substitution and removal
---------------
      Eg. replace a with dd and remove all b

	-First pass count all 'a', while removing b. Overwrite in the same space.
	- now do s.resize(idx + a_cnt)
	- Then start from the end, and keep moving towards the start replacing all 
           occurences of a with 'dd'

	Remember Amazon Echo price reduction problem. remember to use ostringstream


5. Minimum Window Substring (leetcode 76)
-------------
	Given a string S and a string T, find minimum window in S that contains all the characters in T.
	Example:
	Input: S = "ADOBECODEBANC", T = "ABC"
	Output: "BANC"

This is a two pointer solution where you keep moving right pointer until you find a substring that contains all characters of target. Once that happens, you have to start moving left pointer thereby shrinking the substring window to find min substring(if it exists) until you find a substring that doesn't contain all target charcters. 
Now, stop moving left pointer, return the new left pointer and start expanding right pointer again and repeat the process.

To know whether a substring contains target characters, we need two maps. Target will be map<char,int> and substring  will be unordered_map<char,int> 
- Run a forloop for endIndex.
- If character is found in target, save that index in vector, call doesWordContainTarget(targetMap,wordSoFarMap).
	If yes, call checkForTargetInWordSoFar() where the left pointer loops goes through values stored in vector.


6a. Permutation in String (lc 567):
---------
- Here, we use two hashMaps and compare their counts for anagram match.
- Take the first len1 letters in s2, store in s2 and check for anagram. If not, keep moving window to the right by 1 , check for match  until you hit end of s2.


6b. Find All Anagrams in a String (LC: 438)
---------
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
Input:
s: "abab" p: "ab"

-  We store the characters of the target string in hashMap. and also compute the targetSum but adding the integer values of all the characters in targetString
-  Its a valid anagram match when hashMap.count() returns TRUE for every character AND the computedSum=targetSum.
- PLEASE REMEMBER: Use only one hashMap, not two. Use just the start position for checking anagram against pattern. Don't do windowing approach and move the window as in Problem 6a.
-  Once you find anagram, start a loop and check to see if the character to be added next equals first index of the current anagram. If so, keep moving to the right until you find a non-match. 
- Non-match could be of two kinds:
	- The hashmap didn't contain the character at the next Index. In that case, move the loop Index to the next index.
	- Hashmap contained the character at next index, but the outgoing character didnt match the incoming character. In that case, just increment the index by 1.


7. Longest Palindrome substring (lc 5):
-------
 - KEY TAKEAWAY: For each index, check oddPalindrome and evenPalindrome across the entire length of input string 
 
 - This is O(N^2). 
 - Outerloop is to go through each index. 
-  Inner loop will expand outwards from that index on both sides. Handle odd and even palindromes for every index.
	- For odd case, start with given index.
	- For even case, think of starting point as between current index and previous one. Makes it easy to visualize

8. Big Integer Multiply (lc 43):
- KEY TAKEAWAY: Use a hashMap<int,vector<int>> and stack. hashMap key corresponds to the column whose values need to be added 		to get final sum (here, first col is 4+0+0). Prefix number of zeros before you start populating the row.
	E.g. 444*111 =   
		 444
	        4440
	       44400 
    - Handle carry outside the loop for both multiply and then final summation operations.
    - Use stack to store the final sum by *iterating (yes, iterating ) through hMap index and pop out the result into string.
	
================================================
      BINARY SEARCH
================================================
1) This search is done on sorted arrays. Remember the core algo uses only 1 while loop. no recursion. When you see sorted array, it should typically be binary search.

2) To return first element in sorted array with duplicates, the only change is to modify the target<a[mid] check as follows:
	if(target < a[mid] || (target==a[mid] && mid > 0 && a[mid-1]==a[mid])
		high=mid-1;
	else if(target > a[mid])
		low=mid+1
	else
	     	return mid
		
3) To return element closest to a target element (Record and Move-on):
	a) do usual binary search. But for every mid, track min of abs(a[mid]-target)

4) To find minimum in rotated sorted array (all elements unique. If not unique, you have to do O(n) ):
	a) Two key observations: If array is rotated, last element < firstElem. 
		- minimum element is <= lastElem  and 
		- element to left of miniumElement is greater.
	b) last element will "act" as target. If a[mid] > lastElem , move to right. If a[mid]< lastElem, move to left.
	c) If a[mid]<=lastElem  && (mid!=0 && a[mid-1]>a[mid]) return mid
	
5) To determine , square root, run binary search with low=1 and high=x. And only one change to algo:
	- if (mid*mid < x) { low=mid+1;ans=mid; }

6) To find a peak in a regular array where there can be multiple peaks but no two adjacent elements are equal:
	- Deal with boundary (0 and last element) separately by comparing to its neighbor
	-  You compare the middle element against either side. If middle is greater than its neighbors, return it.
	- else if middle < left neightbor, move binary search to left
	- else If middle < right neighbor, move binary search to right.
	
7) Median of two sorted arrays (lc:4)
	- helper function to handle empty arrays
	- helper function to handle when one array's greatest < other array's smallest
	- here consider 4 comparative cases for : (medianIndex+1) vs len1
	- fnd the smaller of the (midIndex1,midIndex2). Lets call it target.  
	   In the other array, compute index  whose value <= target using binary search using record and move-on. We call this 
	       newIndex =findIndexLessThanMidValue().
	- Now compute numIndicesToAccountFor. 
	*  If it is zero, you handle is separately 
	*  If it is non-zero,move to right of numIndex1 (& in nums2) storing prev and curr until numIndicesToAccountFor=0
		
================================================
      PERMUTATION/COMBINATIONS
================================================
The code structure for these problems are generally like this:
	a) run for loop
	b) do some operation, 
	c) recurse (with incrementing index)
	d) undo operation
	e) termination condition at the start
	
- For combination, the comboHelper will do a for-loop with *for-loop-Index* (passed-by-value) getting incremented with every recursive call. 
	- Remember, terminating condition requires checking vector size()
	for(...){
		vector.push_back();
		comboHelper(forloopIndex+1,...)
		vector.pop_back();
	}
	
- For permutation, we use swap, not push/pop . The helper will do a for-loop with *main index* (passed-by-value) incrementing with every recursive call.
	- Remember , terminating condition is to see if mainIndex has reached input size.
	for(i=mainIndex; .. ;..){
		swap(nums[mainIndex],nums[i]);
		permuteHelper(mainIndex+1,...)
		swap(nums[mainIndex,nums[i])
	}
- For permutation with duplicates, same as above only difference is to sort the vector first, and skip duplicates before recursion.
	-  sort(v.begin(),v.end());
	-  call helper(index,...)
	-  helper :
		for(i=mainIndex; .. ;..){
			if(i!=index && nums[i]==nums[index]) skip;
			swap(nums[mainIndex],nums[i]);
			permuteHelper(mainIndex+1,...)	
		}
		
- In coinSum, to print all combinations, it's just the same as combinationSum where 
	 for coins loop {
	     vector.push_back(coins[i])
	     recursive call (with same forLoopIndex,sum+coins[i])
	     vector.pop_back()
	 }

- Refer to powerSetsCombinationPermutationsCoinSum.cpp for actual code
- Time complexity: Exponential. How? https://stackoverflow.com/questions/13467674/determining-complexity-for-recursive-functions-big-o-notation

================================================
RECURSION/BACKTRACKING
================================================

1) Maze Problem:
========
- UniquePaths in MxN = (UniquePaths in MxN-1) + (UniquePaths in M-1xN)
- Need to use ordered map<pair<int,int>,int>.
- Terminating condition: if (m==0 || n==0) , return 1;
- Now if they ask you to print all the paths, you can't use the above logic. Then, start from (0,0). Every time you make a call to right or down, push_back  R or D to a vector and recurse. When you reach (row==m-1 && col==n-1), increment ans, and also push the vector to vector<vector>

1 b) Maze with obstacles
===========
- when you have obstacles, you'll have three if conditions for recursion. 
     a) upper row blocked, left col not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m,n-1, mMap);
     b) left col blocked, upper row not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap);
     c) upper and left unblocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap) + uniquePathsWithObstacles(grid, m,n-1, mMap);
	  
- Handle m==0 and n==0 by saving & returning 0 when blocked	

	Other easy solution: https://leetcode.com/problems/unique-paths-ii/discuss/23248/My-C%2B%2B-Dp-solution-very-simple!

2) N-Queens Puzzle
=======
Important Aspect: 
	code  structure is just like combinatorial recursion problem : 
	a) run for loop b) do some operation,  c) recurse (with incrementing index) d) undo operation
	
- Here, rowIndex is incremented by 1. And we recurse only if we placed the queen
- For each row, we loop thru all columns placing Queen after column, left diagonal & right diagonal conditions are met. 
- The line after recurse will reset the position of Q  so that we could find new positions.


 3) Word Break Problem:
 ========
 Input = "ilikemangotango"
Output: 
"i like mango tango" 
"i like man go tan go" 
"i like mango tan go" 
"i like man go tango"

Important aspect: 2 recursive call for every index and hashSet indicating whether a word was at the index.

- Grab substr at every index:
- You need a hashSet<int> to keep track of whether a word was found at that index i. This is to pop the word and continue forming next bigger word
- For a given index, if word found from input hash set, add it to wordVec and update hashSet at this index. 
	- If this is last word of input sentence, add it to ans. 
	- Else recurse with next index and length set to 1 : 
		helper(s,hSet,str,index+len,1,ans,wordFoundPos,wordVec);
- For the same index, if hashSet<int> indicates there was a word there,  pop the word and clear the hashSet field
-  Recurse to include next index to form larger word .
        helper(s,hSet,str,index,len+1,ans,wordFoundPos,wordVec); 
- Code here: https://leetcode.com/submissions/detail/253027047/ 
	
================================================
     3 .  LINKED LISTS
================================================

A. Append Function : 
------------------------------------------------
Write append function of List class that can be re-used. You need to know tail to write this fuction. 
This function will be useful in many problems especially when sorting a list containing subset of values 
(e.g. 1,2,3 where you create 3 heads and 3 tails for each value  and  then result list where the 3 lists are 
appended one after  another. Note you are re-using the nodes and not creating new copies. 
Refer to interviewcamp for clarification)


B. Detect Cycle in Linked List (this logic is important. Notice the if loop part is identical to while loop logic):
------------------------------------------------
slow=head; 
fast = head;
while(fast!=null){
	fast=fast->next;
	if(fast==slow)
		return true; //cycle exists
	if(fast!=null){
		fast=fast->next;
		if(fast==slow)
			return true;
	}
	slow=slow->next;
}
return false;


C. Length of Cycle in List:
------------------------------------------------
Once you determine fast meets slow, exit the loop, move fast 1 node at a time until it meets slow again. Compute the length


D. Where Cycle starts in a List
------------------------------------------------
Detect a cycle, then find the length of the cycle L. Once you know the length of the cycle, reset fast and slow back to head of the list. Then,  move fast node forward by L nodes. Now, advance both pointers by 1 until they meet. The node at which they meet will be the start of the cycle.


E. Reversing a list
------------------------------------------------
	-Use prev = NULL, curr = root ; one_ahead=curr->next; Compute one_ahead
	- Compute logic using a  middle node with node on either side. And extend it for first node
	- return prev.
	- If you have to reverse using recursion, use a helper like this:
		recurseReverseList(ListNode* currNode, ListNode* prevNode, ListNode** rootNode)
	  Don't forge to initalize rootNode = &head;
	  
	  
F. Merge Sorted Lists
=======================
	- Relatively straightforward. Figure out the root node first. Set it aside. Keep two pointers, one for each list.
	- while(list1 && list2)
		Pick the minimum.
		
I. Merge k sorted lists (lc 23)
-------
- Find minimum value first. Store that as root node. 
- Use a hashset to store all the nodes, grab the minumum node, add it to final list,  and then erase the min node and add minNode->next
- while(hashSet not empty){
	walk through hash set and grab the minimum node from the hashSet and add to final list
   }
   
   
G. Palindrome List
=========
-  Do fast-slow trick to get to middle of the list. Important logic
  Node* fast=head;
  Node* slow=head;
  while(fast->next && fast->next->next){
  	slow=slow->next;
	fast=fast->next->next;
  }
- Now, slow points to middle. Save slow->next as head of second half of list  that you gotta reverse.
- slow->next is then set to NULL
-Once the list is reversed, compare the head and new reversed list node by node for equality
- If second list doesnt return null, it means it's not palindrome! Make sure to put that slow->next back to saved value.

		
H. LRU Cache
======
- Cache is a linked list. It will be list of keys. 
- At any given point, the last element of the list will be the LRU element (ready to be evicted if need be).
- When you read from a cache, that entry is updated to the head of the list if the entry is present. If the entry is not present, you return invalid. 
- When you write to cache, again you update the entry to the head of the list if it exists. If it doesnt exist, you add that entry to the front of the list. If the cache size is full, then you gotta evict the LRU element, which will be the last element of the list bfore adding the element to the front of the list.
- To implement, we need the one STL list and two STL unordered_maps as follows:
	- list<int> cache
	- unordered_map<int, list<int>::iterator> hMap
	- unordered_map<int, int> kvMap;
- We need to implement the following functions:
	- int get(key) : will call updateCache()
	- void put(key,value)   :  will call updateCache() and/or evict()
	- void evict()
	- void updateCache(key)
- Be familiar with C++ STL list.


I. Removing duplicates in a List: O(n^2):
=========
checkDup(Node* root){
	Node* current = root; Node* runner;
	while(current!= null){
		runner = current;
		while(runner.next != null){
			if(runner.next.data==current.data)
				runner.next = runner.next.next
			else
				runner = runner.next
		}
		current = current.next
	}
}

================================================
     4 .  STACK
================================================

A. Postfix Expression
======
 - Need only one stack<string> for operands. when you encounter operator, you pop two from stack and process it.
 - Use stoi() for computation with operator and to_string() to put it back in stack
 
 
B. Infix expression aka Basic Calculator (with or without paranthesis)
=============
- KEY TAKEAWAYS: 2 stacks, assigning priority to operators, handling all operators in stack >= current operator priotity, and processing all operatots until you hit '(' when you encounter ')'

- Set priority value for operators as follows:
	int getOperatorPrecedence(char c) {
        	if (c=='*' || c=='/')
            		return 2;
       		if (c=='+' || c=='-')
            		return 1;
        	else if (c=='(')
            		return 0;
        	else
            	    return -1; //  for ')'
 	}
- if you see operand , put it in the operand stack<int>
- else if when you see '(', put it on operator stack<char>
- else if when you see operator ')', process operand until the operator on the stack is '('.
- else if when you see operator, check to see if the top of operator stack has >= than the current operator. If it does, process operand until the operator on the stack is lower than the current operator.
-  If spaces are allowed, keep storing digits until you hit space and that becomes operand.
Refer to my leetcode solution. You call storeOperand() before virtually every character except digit
- Refer to : https://leetcode.com/submissions/detail/229513107/


================================================
     5 .  QUEUE
================================================

A. Ring Buffer or Circular Queue
========
- KEY TAKEAWAY:  back = (back+1)%k;front=(front+1)%k; have a length variable to keep track of elements queued/enqueued
- Implemented as array of fixed size where you insert in the back and dequeue from front.
- In the class definition, have a "length" variable that increments with every enqueue and decrements with every dequeue.
- When length==0, queue is empty; when length==k, queue is full.
- enqueue():
	v[back] = value;
	rear=back;
        back = (back+1)%k;
        ++length;
- dequeue():
	v[front]=-1;
        front=(front+1)%k;
        length--;
	

B. Sliding Window Maximum
=========
- Remember any sliding window problem is almost always queue
- use deque because you need to iterate through the queue
- First walk through k values and store the max of those in output vector.
- From then on, loop through remaining input vector one element at a time.
	 - If new element being considered is > prev max, store the new one.
	 -  If element being removed is the max, you gotta find new max then.
	 -  Else retain the lastly added vector value as new max
	 
	 
C. Implementing Max in Queue in 0(1) lookup
=======
Maintain two queues. One regular queue and another deque for storing max. Dequeueing is removing element from front of deque, enqueuing is more subtle. When the element to be added is > back of deque, keep removing all elements from back
until you find element >= current element.

================================================
     6 .  GRAPHS
================================================
Time complexity: O(V+E) 
Space Complexity: O(V)

1. DFS
-----
void dfs(Node* node){
	node->state=VISITING;
	processNode();
	for(auto& n: node->neighbors){
		if(n->state==UNVISITED)
			dfs(n);
	}
	node->state=VISITED;
}

2. BFS 
-----
- Always has a queue. 
- Core logic starts with while (queue has elements). Before that add that first element to queue and set the state.
- Also when you add neighbors, you update the state before putting it in the queue.

root->state=VISITING;
queue<int> q;
q.push(root);
void bfs(queue<int>& q){
	while(!q.empty()){
	    Node* node = q.top(); q.pop();
	    processNode();
	    for(auto& n: node->neighbors){
	    	if(n->state==UNVISITED){
			n->state=VISITING;
			q.push(n);
		}
	     }
	     node->state=VISITED;
	}
}


3. Clone Graph
------------
- Do a DFS but without any state variables. 
- dfs() returns a new node every time it's called.
-  You need an unordered_map<Node*,Node*> origToCloneMap;


4. Word-Ladder (lc:127) (lc:126)
------
beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5

- Use BFS without state variable,where neighbors are  words that different from current word by 1.
- Once all neighbors are processed for a given word, we increment the output length by 1.This requires a for-loop inside the bfs while()
- Convert input dict to hash set because as words are popped out the queue, they are deleted from the hash set.
- If you need to return all combinations of word ladder instead of just shorest length, then you need only two extra things: 
	unordered_multimap<string,string> 
	retracePath() recursive loop.



5. Course Schedule aka Toploogical Sort (lc 207,lc 210)
------
- Toplogical sort is  DFS + 1 extra line  at the end, which is stack.push(node) . Then pop out stock to get the right order.
- Topological sort only works when there are no cycles. Therefore it works only for directed graphs.
- To solve Course Schedule :
	- unordered_map<int,State>:  to store states for each node
	- a vector of vertices - one per node. This is populated at the same time states are initialized for each node
	- unordered_multimap<int,int>: to store neighbors
	- VERY IMPORTANT: ensure the false is percolated all the way up for recursive DFS calls.



================================================
     7. LineSweep
================================================
The common sequence in most Line Sweep solutions is:
	- break down intervals into Points.
	- sort the points using custom comparator
	- loop through the points
	
	
Merge Intervals (lc: 56):
---------
- Make sure to remove duplicate elements from input vector first
- Created a sorted Point vector using custom comparator for sorting.
- Use count variable that increments for start Point, and decrements for end Point. 
- When count is zero for both start and endPoint, it becomes a legit interval.

Skyline Problem (lc: 218)
------
 Seperate points as startPoints and endPoints. Each point is of the type Point. 
 Sort the points in ascending order based on x-value.
	-For points with same x-value, startPoint comes before endPoint
	- For startPoints/endPoints with same x-value but multiple heights, sort them in descending order.
Walk through the vector of points:
If startPoint:
	If currentHeight>maxHeight, update answer. And heapify height vector.
	Else only heapify height vector
If endPoint:
	Handle duplicate endPoints with different heights first. (More explanation in the code)
	If endPoint height ==currentMaxHeight, remove currentMax and find nextMax from the heap
	else, remove height from heap and heapify.
	
Meeting Rooms (lc: 252,253) : You gotta return min number of rooms given a schedule
-------
   - In the custom comparator endPoint needs to come before startPoint when the values are equal.
   - Increment and decrement count as before. However, when cnt in startPoint exceeds minRooms, you increment minRooms
   	 if(p.start) {
                ++cnt;
                if(cnt > minRooms) 
                    ++minRooms;
          } else 
                --cnt;


================================================
     8. TREES
================================================

A.  Implement InOrder, Pre & Post-order traversal iteratively (lc:145)
-------------
	- Use stack and visited flag. The visited flag is implemented as hashMap<TreeNode*,bool>
	- You pop the node off the stack, check if it is visited,then print. If not, mark it as visited. and the children in 		opposite order.
	- Basically, you add a node stack unvisited, pop it, add it again as visited, and then pop it to print it.
	- while(stack not empty){
		if(hMap[node])
			print
		else {
		    node->visited=true;
		    now push nodes in reverse of the order asked
		  }
	   }
		    
B. Height Of Tree(i.e. Max Depth of Tree) (lc: 104): 
------
	if(!root) return 0;
	int leftHeight=maxDepth(node->left);
        int rightHeight=maxDepth(node->right);
	return 1+max(leftHeight, rightHeight);
	
	
C. Check Balanced Tree (lc: 110):
------
  - Uses getHeight() as helper function that returns just as above. 
  - This helper also takes bool as reference. We return this bool eventually as final answer. So the final height output is of 		no consequence
  - Compute leftHeight and rightHeight and if difference is > 1, mark bool to be false.
  
  - int getHeight(TreeNode* root,bool& ans){
        if(!root) return 0;
        int leftHeight= getHeight(root->left,ans);
        int rightHeight = getHeight(root->right,ans);
        if(!ans)
            return -1;
        if(abs(leftHeight-rightHeight)>1)
            ans=false;
        
        return 1+ max(leftHeight,rightHeight);
        
    }


D. Longest Path between any two nodes of binary Tree (aka Diameter of Binary Tree) (lc: 543):
-------
 - Almost identical to balanced binary tree implementation except bool& is replaced with int&.
  		int leftHeight=getHeight(root->left,ans);
		int rightHeight= getHeight(root->right,ans);
		ans = max(ans,leftHeight+rightHeight);
		return 1+ max(leftHeight, rightHeight);
 


------------------------------------------------
       BST
------------------------------------------------


------------------------------------------------
Checking if tree is BST
------------------------------------------------
- Always check for nullptr first
- Return false  if node->data is < LOWEST (OR)  > HIGHEST
- return (checkBST(node->left,min,root->data) && checkBST(node->right,root->data,max) )

-------------------------------------------------------------
First occurence of a key in a BST
-------------------------------------------------------------
1) Always check for nullptr first
2) If key matches, recurse left of the tree. 
3) return searchBST(root->data < key ? root->right: root->left , key)

1)In iterative, store the parent value, and call left child when there's key match. 
2) Handle < key  and  > key cases separately.

-------------------------------------------------------------
Next largest key in a BST 
-------------------------------------------------------------
parent = nullptr; curr = root;
Look from subtree perspective.
If subtree value > key, save current as parent, and move current to left child
If subtree value <= key, we don't care  so we keep moving to right.
return parent's data when you exit the loop

-------------------------------------------------------------
K LARGEST ELEMENTS IN BST:
-------------------------------------------------------------
Create a vector to store the K elements.
Call Helper function passing in vec, k and root
Check tree for null and recurse all the way to the right.
Check vector size before pushing tree->data and recurse left by calling tree->left.
Remember to check the size of vector before making a call to right, and left

-------------------------------------------------------------
LOWEST COMMON ANCESTOR (LCA) of two unique elements IN BST
-------------------------------------------------------------
- Consider s to be smaller of the two, b to be larger of the two
- Three while loops
-  when root is not between a&b, traverse left or right depending on
 if it <s or > b.
 In other words,
- 	while (tree->data < s  || tree->data > b){
		while(tree->data < s)
			tree = tree->right.get();
		while(tree->data > b)
			tree = tree->left.get();
	}
	return tree;

-------------------------------------------------------------
INSERITION of KEY IN BST:
-------------------------------------------------------------
prev=nullptr; curr = root.
keep moving left or right until curr = nullptr.
 check whether node needs to be right or left of parent.

-------------------------------------------------------------
DELETION of KEY IN BST:
-------------------------------------------------------------
1.prev=nullptr; curr = root;
2. keep moving left or right until curr = nullptr or curr= key
3 If curr = nullptr, return false.
4. else, if curr has right node,  pick the leftmost of the right subtree, and replace 
the value of curr with that of leftmost node. here logic:  rParent = curr; child = curr->right
5. else, if curr has no right node: 
	a) if curr is root, replace root with curr->left
	b)  take curr->left and assign it to either right or left of parent.
 
-------------------------------------------------------------
CONSTRUCT TREE FROM GIVEN PRE-TRAVERSAL SEQUENECE
-------------------------------------------------------------
HINT: User BST Tree check approach
1.Please note given an in-order traversal, you can get a unique tree structure. Take,{1,2,3}
2. For pre-order traversal, there's a unique sequence.
3. Follow the approach of BST check by using min and max bounds for every recursive call.
	buildTree(){
		index = 0;
		return buildTreeHelper(vec,lower_bound,upper_bound,&index)
	}
4. Key here is to pass the address of index to helper function so that index is updated after every recursive call.
5. Check  *index = vec.size , return nullptr
6. Check vector value <lower_bound || >upperbound, return nullptr;
7. Increment index.
8. return unique_ptr<BSTNOde>(new BSTNode{vector value,
											builTreeHelper(vec,lower_bound,vec[index],index
											builTreeHelper(vec,vec[index],upper_bound,index)
										 } 
							  )


-------------------------------------------------------------
CONSTRUCTT MINIMAL HEIGHT BST TREE FROM A SORTED ARRAY
-------------------------------------------------------------
TreeNode createMinBST(arr[],int start, int end){
	int mid =start+end/2;
	Treenode n = new (arr[mid]);
	n.left = createMinBST(arr,start,mid-1);
	n.right = createMinBST(arr,mid+1,end);
	return n;

}


================================================
					RECURSION
================================================

TOWER OF HANOII
-------------------------------------------------------------
The key observation is move e all other rings (n-1) except base ring src peg to helper peg.
Then you push base ring to the destination peg.
Push n-1 rings back from the helper peg to the destination peg.

Do this until n>0


B. 
------------------------------------------------
MERGING TWO LISTS
------------------------------------------------
	-Create a shared pointer to new dummy_node, and have a 'tail' point to it.
	-call MergeNode(&lowestValueNode,&tail) when both lists have non-NULL nodes .
	Plese make sure you pass pointers to shared pointers.
	- Make tail point to non-NULL node once you are out of MergeNode()
	-return dummy_node->next;


	

------------------------------------------------
DICTIONARY ORDERING
------------------------------------------------
- The  very last element of the dictionary order is all elements in descending order

- So look for case when a[k]> a[k+1] and all after k are in descending order
- pick the element from the descending order higher than a[k]. Swap it
- Reverse the descending ordered part, i.e. after a[k]

