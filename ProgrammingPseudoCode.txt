
================================================
    ARRAYS
================================================

------------------------------------------------
Array tricks to explore
------------------------------------------------
- Having a separate index from loop index as in above two cases.
- See if you can traverse from end to front instead of regular front to end.
- See if you can have start and end pointers and move towards the middle.
- Using dutch national flag.

------------------------------------------------
Sub-array sum
------------------------------------------------
In most sub-array sums, you'll have a running sum and a hashMap.

1: To determine max sum in array with  +ve & -ve, you have to determine local max at every index and global max across all indices. Return global max.

2: To determine *NUMBER* of subarrays that sum to K, keep a running sum
	a) hMap[0]++
	b) if(hMap.count(sum-k)) ans+= hMap[sum-k];
	c) hMap[sum]++
	
3: To check if the NON-negative array has a continuous subarray of size at least 2 that sums up to a multiple of k
 	Key: Remember remainder theorem: (A+(n * k)) % k = A%k.
  	a) hMap[0]=-1;  //to handle two successive zeros.
        b) runningSum %= k;  //when k!=0
        c) if(hMap.count(runningSum)){
                if(i-hMap[runningSum] > 1)
                    return true;
            }
            else
                hMap[runningSum]=i;
 
 4. 3 sum or  4 sum problem where any a+b+c=target in a given array, it follows a different pattern as follows.
 	- sort the vector first
	- Outer for-loop runs the lenght of vector.
	- Last two nums will be taken from start and end of the vector converging inwards in a while loop
		 for(i=0;...){
		 	newTarget=target-nums[i] ; j=i+1; k=nums.size()
		 	while(j<k) {
				if(nums[j]+nums[k] < newTarget)
					j++;
				if(nums[j]+nums[k] > newTarget)
					--k;
				else (nums[j]+nums[k]==target)
			   		store the values, eliminate duplicates for nums[j] and nums[j] using two while loops
		  	}
			another while loop for eliminating duplicates of nums[i]
		   }
		 
 
================================================
      BINARY SEARCH
================================================
1) This search is done on sorted arrays. Remember the core algo uses only 1 while loop. no recursion. When you see sorted array, it should typically be binary search.

2) To return first element in sorted array with duplicates, the only change is to modify the target<a[mid] check as follows:
	if(target < a[mid] || (target==a[mid] && mid > 0 && a[mid-1]==a[mid])
		high=mid-1;
	else if(target > a[mid])
		low=mid+1
	else
	     	return mid
		
3) To return element closest to a target element (Record and Move-on):
	a) do usual binary search. But for every mid, track min of abs(a[mid]-target)

4) To find minimum in rotated sorted array (all elements unique. If not unique, you have to do O(n) ):
	a) Two key observations: If array is rotated, last element < firstElem. 
		- minimum element is <= lastElem  and 
		- element to left of miniumElement is greater.
	b) last element will "act" as target. If a[mid] > lastElem , move to right. If a[mid]< lastElem, move to left.
	c) If a[mid]<=lastElem  && (mid!=0 && a[mid-1]>a[mid]) return mid
	
5) To determine , square root, run binary search with low=1 and high=x. And only one change to algo:
	- if (mid*mid < x) { low=mid+1;ans=mid; }

6) To find a peak in a regular array where there can be multiple peaks but no two adjacent elements are equal:
	- Deal with boundary (0 and last element) separately by comparing to its neighbor
	-  You compare the middle element against either side. If middle is greater than its neighbors, return it.
	- else if middle < left neightbor, move binary search to left
	- else If middle < right neighbor, move binary search to right.
	
	
================================================
      PERMUTATION/COMBINATIONS
================================================
The code structure for these problems are generally like this:
	a) run for loop
	b) do some operation, 
	c) recurse (with incrementing index)
	d) undo operation
	e) termination condition at the start
	
- For combination, the comboHelper will do a for-loop with *for-loop-Index* (passed-by-value) getting incremented with every recursive call. 
	- Remember, terminating condition requires checking vector size()
	for(...){
		vector.push_back();
		comboHelper(forloopIndex+1,...)
		vector.pop_back();
	}
	
- For permutation, we use swap, not push/pop . The helper will do a for-loop with *main index* (passed-by-value) incrementing with every recursive call.
	- Remember , terminating condition is to see if mainIndex has reached input size.
	for(i=mainIndex; .. ;..){
		swap(nums[mainIndex],nums[i]);
		permuteHelper(mainIndex+1,...)
		swap(nums[mainIndex,nums[i])
	}
- For permutation with duplicates, same as above only difference is to sort the vector first, and skip duplicates before recursion.
	-  sort(v.begin(),v.end());
	-  call helper(index,...)
	-  helper :
		for(i=mainIndex; .. ;..){
			if(i!=index && nums[i]==nums[index]) skip;
			swap(nums[mainIndex],nums[i]);
			permuteHelper(mainIndex+1,...)	
		}
		
- In coinSum, to print all combinations, it's just the same as combinationSum where 
	 for coins loop {
	     vector.push_back(coins[i])
	     recursive call (with same forLoopIndex,sum+coins[i])
	     vector.pop_back()
	 }

- Refer to powerSetsCombinationPermutationsCoinSum.cpp for actual code
- Time complexity: Exponential. How? https://stackoverflow.com/questions/13467674/determining-complexity-for-recursive-functions-big-o-notation

================================================
RECURSION/BACKTRACKING
================================================

1) Maze Problem:
========
- UniquePaths in MxN = (UniquePaths in MxN-1) + (UniquePaths in M-1xN)
- Need to use ordered map<pair<int,int>,int>.
- Terminating condition: if (m==0 || n==0) , return 1;
- Now if they ask you to print all the paths, you can't use the above logic. Then, start from (0,0). Every time you make a call to right or down, push_back  R or D to a vector and recurse. When you reach (row==m-1 && col==n-1), increment ans, and also push the vector to vector<vector>

1 b) Maze with obstacles
===========
- when you have obstacles, you'll have three if conditions for recursion. 
     a) upper row blocked, left col not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m,n-1, mMap);
     b) left col blocked, upper row not blocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap);
     c) upper and left unblocked:
     	  mMap[make_pair(m,n)] = uniquePathsWithObstacles(grid, m-1,n, mMap) + uniquePathsWithObstacles(grid, m,n-1, mMap);
	  
- Handle m==0 and n==0 by saving & returning 0 when blocked	

	Other easy solution: https://leetcode.com/problems/unique-paths-ii/discuss/23248/My-C%2B%2B-Dp-solution-very-simple!

2) N-Queens Puzzle
=======
Important Aspect: 
	code  structure is just like combinatorial recursion problem : 
	a) run for loop b) do some operation,  c) recurse (with incrementing index) d) undo operation
	
- Here, rowIndex is incremented by 1. And we recurse only if we placed the queen
- For each row, we loop thru all columns placing Queen after column, left diagonal & right diagonal conditions are met. 
- The line after recurse will reset the position of Q  so that we could find new positions.


 3) Word Break Problem:
 ========
 Input = "ilikemangotango"
Output: 
"i like mango tango" 
"i like man go tan go" 
"i like mango tan go" 
"i like man go tango"

Important aspect: 2 recursive call for every index and hashSet indicating whether a word was at the index.

- Grab substr at every index:
- You need a hashSet<int> to keep track of whether a word was found at that index i. This is to pop the word and continue forming next bigger word
- For a given index, if word found from input hash set, add it to wordVec and update hashSet at this index. 
	- If this is last word of input sentence, add it to ans. 
	- Else recurse with next index and length set to 1 : 
		helper(s,hSet,str,index+len,1,ans,wordFoundPos,wordVec);
- For the same index, if hashSet<int> indicates there was a word there,  pop the word and clear the hashSet field
-  Recurse to include next index to form larger word .
        helper(s,hSet,str,index,len+1,ans,wordFoundPos,wordVec); 
- Code here: https://leetcode.com/submissions/detail/253027047/ 
	
================================================
     3 .  LINKED LISTS
================================================

Append Function : Write append function of List class that can be re-used. You need to know tail to write this fuction. This function will be useful in many problems especially when sorting a list containing subset of values (e.g. 1,2,3 where you create 3 heads and 3 tails for each value  and  then result list where the 3 lists are appended one after  another. Note you are re-using the nodes and not creating new copies. Refer to interviewcamp for clarification)
------------------------------------------------
MERGING TWO LISTS
------------------------------------------------
	-Create a shared pointer to new dummy_node, and have a 'tail' point to it.
	-call MergeNode(&lowestValueNode,&tail) when both lists have non-NULL nodes .
	Plese make sure you pass pointers to shared pointers.
	- Make tail point to non-NULL node once you are out of MergeNode()
	-return dummy_node->next;

------------------------------------------------
Reversing a list
------------------------------------------------
	-Use prev = nullptr, curr = root ; one_ahead=curr->next; Compute one_ahead
	- Compute logic using a  middle node with node on either side. And extend it for first node
	- return prev.

------------------------------------------------
DICTIONARY ORDERING
------------------------------------------------
- The  very last element of the dictionary order is all elements in descending order

- So look for case when a[k]> a[k+1] and all after k are in descending order
- pick the element from the descending order higher than a[k]. Swap it
- Reverse the descending ordered part, i.e. after a[k]


------------------------------------------------
     2 .  STRING
------------------------------------------------
For strings remmeber to use for(char& c: s)

------------------------------------------------
Palindrome string
------------------------------------------------
Two indices: at start and end. 
Use isaplhanum() and tolower()

------------------------------------------------
Reverse sentence
------------------------------------------------
-3 calls to reverse()

-Reverse the whole sentence using reverse()
-then reverse one word at a time. use 
	while(end = s.find(" ",start) != string:npos)
		reverse(s.begin()+start,s.begin()+end)
		start= end+1;
-
reverse(s.begin()+start,s.end())


------------------------------------------------
RunLength Encoding/Decoding
------------------------------------------------
aaabbbc= 3a3b1c

- Use a second string to copy the results over. like this:
	results += 

- to_string(integer) and is_digit(char)


------------------------------------------------
Character substitution and removal
------------------------------------------------
Eg. replace a with dd and remove all b

-First pass count all 'a', while removing b. Overwrite in the same space.
- now do s.resize(idx + a_cnt)
- Then start from the end, and keep moving towards the start replacing all 
occurences of a with 'dd'

Remember Amazon Echo price reduction problem. remember to use ostringstream





------------------------------------------------
       BST
------------------------------------------------


------------------------------------------------
Checking if tree is BST
------------------------------------------------
- Always check for nullptr first
- Return false  if node->data is < LOWEST (OR)  > HIGHEST
- return (checkBST(node->left,min,root->data) && checkBST(node->right,root->data,max) )

-------------------------------------------------------------
First occurence of a key in a BST
-------------------------------------------------------------
1) Always check for nullptr first
2) If key matches, recurse left of the tree. 
3) return searchBST(root->data < key ? root->right: root->left , key)

1)In iterative, store the parent value, and call left child when there's key match. 
2) Handle < key  and  > key cases separately.

-------------------------------------------------------------
Next largest key in a BST 
-------------------------------------------------------------
parent = nullptr; curr = root;
Look from subtree perspective.
If subtree value > key, save current as parent, and move current to left child
If subtree value <= key, we don't care  so we keep moving to right.
return parent's data when you exit the loop

-------------------------------------------------------------
K LARGEST ELEMENTS IN BST:
-------------------------------------------------------------
Create a vector to store the K elements.
Call Helper function passing in vec, k and root
Check tree for null and recurse all the way to the right.
Check vector size before pushing tree->data and recurse left by calling tree->left.
Remember to check the size of vector before making a call to right, and left

-------------------------------------------------------------
LOWEST COMMON ANCESTOR (LCA) of two unique elements IN BST
-------------------------------------------------------------
- Consider s to be smaller of the two, b to be larger of the two
- Three while loops
-  when root is not between a&b, traverse left or right depending on
 if it <s or > b.
 In other words,
- 	while (tree->data < s  || tree->data > b){
		while(tree->data < s)
			tree = tree->right.get();
		while(tree->data > b)
			tree = tree->left.get();
	}
	return tree;

-------------------------------------------------------------
INSERITION of KEY IN BST:
-------------------------------------------------------------
prev=nullptr; curr = root.
keep moving left or right until curr = nullptr.
 check whether node needs to be right or left of parent.

-------------------------------------------------------------
DELETION of KEY IN BST:
-------------------------------------------------------------
1.prev=nullptr; curr = root;
2. keep moving left or right until curr = nullptr or curr= key
3 If curr = nullptr, return false.
4. else, if curr has right node,  pick the leftmost of the right subtree, and replace 
the value of curr with that of leftmost node. here logic:  rParent = curr; child = curr->right
5. else, if curr has no right node: 
	a) if curr is root, replace root with curr->left
	b)  take curr->left and assign it to either right or left of parent.
 
-------------------------------------------------------------
CONSTRUCT TREE FROM GIVEN PRE-TRAVERSAL SEQUENECE
-------------------------------------------------------------
HINT: User BST Tree check approach
1.Please note given an in-order traversal, you can get a unique tree structure. Take,{1,2,3}
2. For pre-order traversal, there's a unique sequence.
3. Follow the approach of BST check by using min and max bounds for every recursive call.
	buildTree(){
		index = 0;
		return buildTreeHelper(vec,lower_bound,upper_bound,&index)
	}
4. Key here is to pass the address of index to helper function so that index is updated after every recursive call.
5. Check  *index = vec.size , return nullptr
6. Check vector value <lower_bound || >upperbound, return nullptr;
7. Increment index.
8. return unique_ptr<BSTNOde>(new BSTNode{vector value,
											builTreeHelper(vec,lower_bound,vec[index],index
											builTreeHelper(vec,vec[index],upper_bound,index)
										 } 
							  )


-------------------------------------------------------------
CONSTRUCTT MINIMAL HEIGHT BST TREE FROM A SORTED ARRAY
-------------------------------------------------------------
with start = 0; end  = vec.size(); 
call buildTreeHelper(vector,start,end)



================================================
					RECURSION
================================================

TOWER OF HANOII
-------------------------------------------------------------
The key observation is move e all other rings (n-1) except base ring src peg to helper peg.
Then you push base ring to the destination peg.
Push n-1 rings back from the helper peg to the destination peg.

Do this until n>0
