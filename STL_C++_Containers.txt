C++ STL CONTAINERS


================Stack==================
stack<int> s;
s.push() or s.emplace()
s.pop();
int a = s.top();




================Queue==================
queue<int> q;
q.push() or q.emplace()
q.pop();
int a = q.front();



===============Dequeue==================
dequeue<int> q;
dq.push_front() or dq.push_back();
dq.pop_front() or dq.pop_back();
dq.front() or dq.back()



===============String==================
string s;
stringstream sstrm;
sstrm<<s;
sstrm<<s.str();
getline(sstrm,s, ',')    - will read a line from a string stream seperated by ',' and store the value one at a time in s
						So always call it in a loop to get values repeatedly.

s.find("string", pos = 0) - returns pos. else check for string::npos
s.find('c',pos = 0)
reverse(s.begin() + 3, s.end() -4);
sort(s.begin(), s.end());

============unordered_map============
unordered_map<int,int> hMap;
hMap[key]=value;
hMap.count(key) // to check whether the key exists . Returns 0 if it doesnt exist.

============unordered_set============
unordered_set<int> dict;  			//This is just hash map, except that key and value are the same.
unordered_set<int> dict(v.begin(),v.end()) 	//Converting vector into a hash set.
dict.find(elem) != dict.end().    		//finding element in the set
dict.emplace(elem) or dict.insert(elem)		//elem inserted if not present 		         
dict.erase(elem)				//elem erased if found

============unordered_multimap============    //used when same key has multiple values
unordered_multimap<string,string> hMap;
hMap.emplace(key, value)			//No [] operator for multimap.
hMap.erase(key)					//Will erase all the values associated with key
auto range=matchingMap.equal_range(key);	//finding all values for a given key and browsing thru them
for(auto it=range.first;it!=range.second;++it){
	


===============vector==================
vector<int> v;
v.push_back()
v.pop_back()
v.back()
v.front()
v.clear()
v.erase(v.begin() + 3)
v.begin()
v.end()
v.assign(s.begin(), s.end())
v.resize(sizeWeWant);

std::unique(v.begin().v.end())
std::remove(v.begin(,v.end(),val)
std::find(v.begin(), v.end(), val)
std::fill(v.begin(), v.end(), val)
std::distance(v.begin(), v.end())


- Initializing vector:
	vector<bool> v(count, false);
	
- Initializing 2D vector:
	int m=3,n=5;
	vector<vector<int>> dp(m, vector<int>(n,0));
	
- Zeroing out a vector
	fill(v.begin(), v.end(), 0);
	
- Erasing dupilicates and sorting a vector
	Method1: unique() call moves all duplicates to the end of the sorted vector.And then erase it
		sort( vec.begin(), vec.end() );
		vec.erase( unique( vec.begin(), vec.end() ), vec.end() );
	Method2:
		set<int> s( vec.begin(), vec.end() );
		vec.assign( s.begin(), s.end() );
	Method3:
		set<int> s;
		unsigned size = vec.size();
		for( unsigned i = 0; i < size; ++i ) s.insert( vec[i] );
		vec.assign( s.begin(), s.end() );
		
- Remove element by value
	remove(v.begin(), v.end(),ElemToRemove) - 
	This moves all "ElemToRemove" values to the very end of the vectot and returns the iterator to the very first of all           the removed  elements. Therefore, to erase all "ElemToRemove" , you'd do the following:
	
	v.erase(remove(v.begin(), v.end(),ElemToRemove), v.end());

- Sorting vector
	sort(v.begin(), v.end()); 
	OR
	bool sortByName(const Person &lhs, const Person &rhs) { return lhs.name < rhs.name; }
	sort(people.begin(), people.end(), sortByName);

- Vector of bools:
	To keep track of true or false for unknown number of elements.
	Bitset can only be used for fixed size known at compilation time
