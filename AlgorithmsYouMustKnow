1)DUTCH NATIONAL FLAG: (Numbers<Desired Number) should be to left of desired Number, and )numbers > desiredNumber) should be to right of the desired number
  a) Initial Conditions: low,mid=0; high=size-1;
  b) Terminating condition: while(mid<=high)
  c) Core Logic:
      if(nums[mid]==desiredNum)
          ++mid;
      else if(nums[mid]<desiredNum)
          swap(nums[mid],nums[low]);
          ++low;
          ++mid;
       else if(nums[mid]>desiredNum)
          swap(nums[mid],nums[high]);
          --high;

2) MERGE SORT: (aka Divide and Conquer). : O(nlogn) time and O(n) space
  Key Logic: Split the vector in middle.
             mergeSort the left half
             mergeSort the right half
             merge the two halves (rememeber: merging two sorted vectors using pointers. Always require O(n) space, and O(n) time)
    a) Initial Conditions:start=0;end=size-1;
    b) Terminating condition : if(start>=end) return
    c) Core Logc:
        mid=start+(end-start)>>1;
        mergeSort(v,start,mid);
        mergeSort(v,mid+1,end);
        merge(a,start,mid,end) : here merge two sorted vectors, copy the results back into original vector.
    
    
        
3) QUICKSORT: Worse case O(n^2),Avg case O(nlogn), Space: O(1)
     Key Logic:
     This algo is a variation of DNF with new random pivot point every time.
     Pick a random pivot. Apply DNF. 
     From the obtained low and high, Repeat above steps on the lowerHalf of pivot and then on upper-half of pivot
     
     a) Initial Conditions:start=0;end=size-1;
     b) Terminating condition : if(start>=end) return
     c) Core Logic:
        -call quickSort(v,start,end)
        -Pick a random Index and call the element at that index to be pivot.
        -Call partition(v,start,end,pivot) to return {belowPivotIndex,afterPivotIndex}. 
          This implementation is DNF because we want (values < pivot) THEN (values==pivot) THEN (values after pivot)
        - call quickSort(v,start,belowPivotIndex)
        - call quickSort(v,afterPivotIndex,end)
        
 4) Binary Search:
    - Remember only 1 while loop. Recursion is unnecessary.
    
      bool binarySearch(array, target) {
           while(low<=high){
             mid=low + ((high-low)>>1);
            if(target<a[mid])
              high=mid-1;
            else if(target>a[mid])
              low=mid+1;
             else
              return true;
           }
           return false;
      }
            
      
  5. BFS
  ==========
  - Needs a queue with starting position. 
  - Outer while loop to process q until queue is empty
  - Inner for loop to process current queue size.
  
   int dir[8][2] = {{1,0},{-1,0},{0,-1},{0,1},{1,1},{1,-1},{-1,-1},{-1,1}};
   int steps=0;
   while(!q.empty()){
            ++steps;
            for(int k=q.size();k>0;k--){
                row = q.front().first;
                col = q.front().second;
                q.pop();
                for(auto& d: dir){
                    i = row + d[0];
                    j = col + d[1];
                    if(i>=0 && j>=0 && i<n && j < n && !grid[i][j]){
                        q.push({i,j});
                        grid[i][j]=1;
                    }
                }
            }
        }


6. A* algorithm - Not a must to know but if interested. 
========
It's based on heuristic at every step of the path.
https://leetcode.com/problems/shortest-path-in-binary-matrix/solution/


PITFALLS of in-place algorithm:

================
However, like all in-place algorithms, overwriting the input can cause problems. Here are a couple of possible scenarios you need to consider.

1) That the algorithm is running in a * multithreaded* environment, and it does not have exclusive access to the grid. 
Other threads might need to read the grid too, and might not expect it to be modified.

2) That there is only a single thread or the algorithm has exclusive access to the grid while running, 
but the grid might need to be reused later or by another thread once the lock has been released.

